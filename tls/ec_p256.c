/**
 *		Tempesta TLS
 *
 * Elliptic curve NIST secp256r1 (prime256v1, short Weierstrass).
 * See implementation references in ecp.c.
 *
 * Copyright (C) 2020 Tempesta Technologies, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include "lib/str.h"
#include "asn1.h"
#include "bignum_asm.h"
#include "ecp.h"
#include "mpool.h"

#define G_BITS		256
#define G_LIMBS		(G_BITS / BIL)
#define G_W		7			/* m * G window */
#define G_W_SZ		(1U << (G_W - 1))	/* m * G window size */
#define G_D		((G_BITS + G_W - 1) / G_W) // 37
#define W		4			/* m * P window */
#define W_SZ		(1U << (W - 1))		/* m * P window size */
#define D		((G_BITS + W - 1) / W)

static const struct {
	unsigned long	secp256r1_p[G_LIMBS];
	unsigned long	secp256r1_b[G_LIMBS];
	unsigned long	secp256r1_n[G_LIMBS];
	unsigned long	secp256r1_gx[G_LIMBS];
	unsigned long	secp256r1_gy[G_LIMBS];
	unsigned long	secp256r1_gz[G_LIMBS];

	TlsMpi		P;
	TlsMpi		B;
	TlsMpi		N;
	TlsMpi		__align_placeholder;
	TlsEcpPoint	G;
} ____cacheline_aligned __attribute__((packed)) G = {
	/*
	 * Domain parameters for secp256r1 (prime256v1) - generalized Mersenne primes.
	 */
	.secp256r1_p = {
		0xffffffffffffffffUL, 0xffffffffUL, 0UL, 0xffffffff00000001UL
	},
	.secp256r1_b = {
		0x3bce3c3e27d2604bUL, 0x651d06b0cc53b0f6UL,
		0xb3ebbd55769886bcUL, 0x5ac635d8aa3a93e7UL
	},
	.secp256r1_n = {
		0xf3b9cac2fc632551UL, 0xbce6faada7179e84UL,
		0xffffffffffffffffUL, 0xffffffff00000000UL
	},
	.secp256r1_gx = {
		0xf4a13945d898c296UL, 0x77037d812deb33a0UL,
		0xf8bce6e563a440f2UL, 0x6b17d1f2e12c4247UL
	},
	.secp256r1_gy = {
		0xcbb6406837bf51f5UL, 0x2bce33576b315eceUL,
		0x8ee7eb4a7c0f9e16UL, 0x4fe342e2fe1a7f9bUL
	},
	.secp256r1_gz = {
		1, 0, 0, 0
	},
	.P = {
		.s	= 1,
		.used	= G_LIMBS,
		.limbs	= G_LIMBS,
		._off	= -6 * (short)(G_LIMBS * CIL)
	},
	.B = {
		.s	= 1,
		.used	= G_LIMBS,
		.limbs	= G_LIMBS,
		._off	= -5 * (short)(G_LIMBS * CIL) - (short)sizeof(TlsMpi)
	},
	.N = {
		.s	= 1,
		.used	= G_LIMBS,
		.limbs	= G_LIMBS,
		._off	= -4 * (short)(G_LIMBS * CIL) - 2 * (short)sizeof(TlsMpi)
	},
	.__align_placeholder = {},
	.G = {
		.X = {
			.s	= 1,
			.used	= G_LIMBS,
			.limbs	= G_LIMBS,
			._off	= -3 * (short)(G_LIMBS * CIL)
				  - 4 * (short)sizeof(TlsMpi)
		},
		.Y = {
			.s	= 1,
			.used	= G_LIMBS,
			.limbs	= G_LIMBS,
			._off	= -2 * (short)(G_LIMBS * CIL)
				  - 5 * (short)sizeof(TlsMpi)
		},
		.Z = {
			.s	= 1,
			.used	= 1,
			.limbs	= G_LIMBS,
			._off	= -1 * (short)(G_LIMBS * CIL)
				  - 6 * (short)sizeof(TlsMpi)
		}
	}
};

typedef struct {
	unsigned long	x[G_LIMBS];
	unsigned long	y[G_LIMBS];
} EcpXY;

typedef struct {
	TlsEcpPoint	p;
	unsigned long	x[G_LIMBS * 2];
	unsigned long	y[G_LIMBS * 2];
	unsigned long	z[G_LIMBS];
} TmpEcpPoint;

/* Static precomputed table for the group generator. */
static const EcpXY combT_G[G_W_SZ] __page_aligned_data = {
	/*
	 * Generated by t/tgen_ec256.c for G_W_SZ=64, total size = 4096.
	 */
	{{0xf4a13945d898c296UL, 0x77037d812deb33a0UL,
	  0xf8bce6e563a440f2UL, 0x6b17d1f2e12c4247UL},
	 {0xcbb6406837bf51f5UL, 0x2bce33576b315eceUL,
	  0x8ee7eb4a7c0f9e16UL, 0x4fe342e2fe1a7f9bUL}},
	{{0x58bdfa8e66d4e2bcUL, 0x8f77a5699b1f858bUL,
	  0xfeec5805b6fb1070UL, 0x1cdf701e9d64351fUL},
	 {0xba4270422783ba45UL, 0x54b09ce3f7665b19UL,
	  0xbca94aa8c656862UL, 0xc37d7f62c43c6b76UL}},
	{{0x49f68919717a0611UL, 0x3976a29628f17701UL,
	  0x9cdeb9d5df3cb83UL, 0x183c55cccfb6448fUL},
	 {0x1b6d1b3f70efbce8UL, 0x79ff4484167e6228UL,
	  0xfa41c36ff6290b34UL, 0xeaef1249e5b76b65UL}},
	{{0xb41b1d2da97ab1ecUL, 0xb791778483ceba2bUL,
	  0x45fbec0d8d2850deUL, 0x7a20b5fd3a6376b1UL},
	 {0xb2d21722685f8d97UL, 0xa073f8d622ee2184UL,
	  0x97cc89513f46a374UL, 0x477f1d41175fadadUL}},
	{{0x16305832fc602827UL, 0x8e0b37955c1b372UL,
	  0x7dcb57f72aa3a67bUL, 0x5ff1b63d4fb0f09aUL},
	 {0x370a46361c854f7fUL, 0xd837f9a72830f455UL,
	  0xaa0d33f2a2d58aceUL, 0x562e4757c490b3f0UL}},
	{{0x8157fd7f79023d63UL, 0x7f9603bf056de78bUL,
	  0x3790a889214df921UL, 0xa20ccb8e9a3a5a1aUL},
	 {0x9beb594bf75787b1UL, 0xdd806f4f86119c08UL,
	  0x6d3a51e8d8071364UL, 0xfcaa5616157a43aaUL}},
	{{0x517cac57375c4aebUL, 0x352499bc4ff16bd2UL,
	  0x2c1b1032b0d265e8UL, 0x2db3b36bf4174ea4UL},
	 {0x626c820d3315c1a4UL, 0xc0e3ce26f851dcc4UL,
	  0x274f1dfc8e9ee4e8UL, 0x3030e74ee6039e6eUL}},
	{{0xd7bb0d963488885fUL, 0xbe034befd505f8f6UL,
	  0x64cd8f6e32acf6ccUL, 0x915f8e4cab84b50fUL},
	 {0x642ae382dc91bd4UL, 0x966c989eaa59ac9eUL,
	  0x2d5eadc1fc41c571UL, 0x43f8da79ef9d42cbUL}},
	{{0x276cb26dca5e59adUL, 0xb688aafb13041de1UL,
	  0x2f7d2235143bcf73UL, 0xa91c74975977e774UL},
	 {0xf60def812f9d1ac9UL, 0xc67d5ea86e16ee7UL,
	  0x85dd2dd94730f8d1UL, 0xf59a5dd73b61ef8aUL}},
	{{0xacc489037595efcfUL, 0x4a5b71716a99cfd4UL,
	  0x85bbf7edfedc0578UL, 0x1db5d227f5ec256bUL},
	 {0x6ed1be54ffe44b30UL, 0xb04d68207c5e5a75UL,
	  0xa8fa90ca2aef51daUL, 0x9f26c31d30239a66UL}},
	{{0xfbe8361880a1c3b9UL, 0x9f95b0ae1401c46dUL,
	  0x6c6a8cd04a76b0f7UL, 0x5b246b2999159bdbUL},
	 {0x6e68971a3aff0d3dUL, 0x2b046407fbb6d2f9UL,
	  0xed8e3ff473ab7a26UL, 0xb1cd06239f05a12eUL}},
	{{0xf0d0ac34440b2b4UL, 0x6e5babc4bc2466ebUL,
	  0x75d997e56e87ae5dUL, 0x7b2a3707ca353d97UL},
	 {0x428039e7d2ef2f0dUL, 0x48db0cf6cc91e514UL,
	  0xe15faae7a685b5f5UL, 0x71503b9ea42752ccUL}},
	{{0x2c69afa5fb261aa1UL, 0xead7ebfed0c7a52cUL,
	  0x3daa5f8cb646aa17UL, 0xd1f26b5157a729feUL},
	 {0x2a8c2a344f4a595fUL, 0x85c3e8ce9369f6b9UL,
	  0x1f710903d4c3b33dUL, 0x48f6097248fc1423UL}},
	{{0x84a6754da28f8357UL, 0xa888dbcdb1e5c11cUL,
	  0x4f6d9b114bc3317UL, 0x33f6e36fddf0882eUL},
	 {0x51f4afb5ae7f395cUL, 0xc20ecf5252720c58UL,
	  0xd7311e4fdf7e9952UL, 0x9e193aa7df4f8977UL}},
	{{0xcc5c715c7dbcd045UL, 0xcb2a442f6ac5be08UL,
	  0x6fc337a41a304fd3UL, 0xbe2b31dede391401UL},
	 {0x5204390d4d3d27a8UL, 0xfefc9aab8e70b527UL,
	  0x3f9b7392c7df79dfUL, 0x90eba9be2c667970UL}},
	{{0x28a277c4e76a12ccUL, 0x53bfed843ec44c95UL,
	  0x2aed681120359286UL, 0x41d2ca5752e012eUL},
	 {0x881723b2717476e9UL, 0x60c9ef6ea64a3fe6UL,
	  0x69f0a26e62dd41e9UL, 0x19d42e8cb74fbf79UL}},
	{{0x21d982aa0d850bdUL, 0xad607931684f68ebUL,
	  0x17c84c69ddf6fdcdUL, 0x653daef9eb3f4758UL},
	 {0x3deaa6abef152b37UL, 0xde7fdabef69b2dabUL,
	  0xdd7206b041754fa5UL, 0x2dc979f8f9e0180cUL}},
	{{0xcaa9300db98f8d22UL, 0x2e1dd47bb24f88ecUL,
	  0x9fdbff50b72a2a93UL, 0x8970f0d55d9d5271UL},
	 {0x268f3bcc7c42a345UL, 0xe4cc1179df9f7224UL,
	  0x99ca8ca56abd051UL, 0x2fb9e59985b95353UL}},
	{{0x7432a56831386b9aUL, 0x5eaa5d286b22f44bUL,
	  0xf12faa49bcec4dbfUL, 0x3d79133093b62c32UL},
	 {0x211cc0547caa6385UL, 0x7e56d9b4c3144294UL,
	  0x6792e136ed5ebb8UL, 0x692fdf6eca8404b5UL}},
	{{0x93faa7b8c047ec08UL, 0x75d93a3c2a564e48UL,
	  0x775a58508e40783eUL, 0xee8d540a5723c39UL},
	 {0xd65ac60ead05f672UL, 0x171484012f2ada52UL,
	  0xfd4c754fa1935de7UL, 0xffac4bd5061a7c82UL}},
	{{0x3e9d81c01a6fb1beUL, 0xd9a803ed8653c8e3UL,
	  0x18c67e5a8e49efb2UL, 0x9b3d25f7b9f2ac55UL},
	 {0x313ba23da2a90e50UL, 0x1c09a37e810690bcUL,
	  0xfbe034518b63edaUL, 0x36d4e3086496f26cUL}},
	{{0x1245d89049ebc3edUL, 0x3b98c994bfd91a7eUL,
	  0xf35b885e64ff8b35UL, 0x96660a48f355ffecUL},
	 {0x247a9dae51bbf899UL, 0x16b0668b4f36401bUL,
	  0xb213c88bfc6d187cUL, 0x5501f3e47d325507UL}},
	{{0xddd4eb0f7b7d8dd2UL, 0x3f78f6be5547dfd0UL,
	  0x3a6db541604c7c2eUL, 0x10ca9a6f6f2f1d36UL},
	 {0x174de23527afc848UL, 0x7d7a044f85e89cd7UL,
	  0x378042b8ed532118UL, 0x1d119a381f51fa9fUL}},
	{{0x1957c792545c3f6UL, 0x4dd11bbe59cc90d6UL,
	  0xae52607761ac362bUL, 0xd0cd0c5cdc0a72dUL},
	 {0x71c841c99e4947d7UL, 0x5db7ea1ae05a7686UL,
	  0xf2d5175388bbda1eUL, 0xdd0da9aa110c6d73UL}},
	{{0x24bd92e11f5d4f2eUL, 0x33eed23ded3a7fe3UL,
	  0x30ef32769921bcaaUL, 0xfe1e17206a190783UL},
	 {0xa74bbfcad0b38fc1UL, 0x6ad56fbd26238537UL,
	  0x1453c53fa24dce0dUL, 0xb8d66f8d572e13f3UL}},
	{{0x55135fa96ddba35bUL, 0x3c4793c20c99febaUL,
	  0xa6984ded65cd5361UL, 0xc1e9df7223f804feUL},
	 {0x5161a44d34782a6fUL, 0xc2b442968f580e37UL,
	  0xbb2456ca677f245dUL, 0xf8d4093f6bcd8a73UL}},
	{{0xa9d5f26280c658c5UL, 0x71c15750eda7045cUL,
	  0x54f4299bc92a5ff3UL, 0x607d7c03e7fe3be8UL},
	 {0x1ea184fee3354062UL, 0x7d676238665a39b1UL,
	  0x45280843706292b1UL, 0xf5fb020012dad77fUL}},
	{{0xe1101bf775a86757UL, 0x3f34b01cc58780f2UL,
	  0xfd080f88a62312eUL, 0xb0d3cc7e693bcb40UL},
	 {0xe63ba9c1990247bbUL, 0x97dd0036f1a0521UL,
	  0xba8e4a484ba1cdf9UL, 0xb8e2eb267e38f247UL}},
	{{0x9cfcae873e929ca8UL, 0xf2da271fe8bd2f23UL,
	  0x4539fe3961d7e30UL, 0xa20e7bf67d3492fUL},
	 {0xb614ea24ae6657c2UL, 0x9cce0ecf9a218f37UL,
	  0xa549588d745fc317UL, 0xb33443648f34fc73UL}},
	{{0xca0bb384ae118becUL, 0x7e5efc7a2d6ec371UL,
	  0x35ca3d70931f7a75UL, 0x972b1cec11152993UL},
	 {0x4803e014fe636b50UL, 0xa1519bcbbc38f77dUL,
	  0xdb75a8297bea81edUL, 0x3f2043e5da4b0f60UL}},
	{{0xc6b3f2ad2c206717UL, 0xf1692c2675abd071UL,
	  0xbdd153de7394c19cUL, 0x447bcd3b89285704UL},
	 {0x78da031d34641e7fUL, 0x8e6ae13ba80bc2d0UL,
	  0x72648472341942bbUL, 0x57c7ce3ed78b4f89UL}},
	{{0xc0ba31a4d9fc1b22UL, 0x60a1ae4c13b372b4UL,
	  0x7434dd76cc798845UL, 0xa7e388bf038a735dUL},
	 {0x1124e44e3405bc7dUL, 0x4386fe5f3b79415dUL,
	  0xc43dc6fff54544e3UL, 0x73ca7b06310f5380UL}},
	{{0x90a24801f40e5465UL, 0x2f5a55365d1db99eUL,
	  0x2576a4713bd54e4bUL, 0xe87dcf14d2f78e00UL},
	 {0x31278d3d66dafb79UL, 0xa942cf129091c8acUL,
	  0x55c2d2b384b5b27bUL, 0x52d5cee6ab579fe1UL}},
	{{0xa1a8ffd46d6585d1UL, 0xa149e128abafa172UL,
	  0x8f5b3ade78d9712aUL, 0x9c70167c0c2862cbUL},
	 {0x6d636942e2584aecUL, 0xc7aa1f93c5dd4e2cUL,
	  0x5bfa87232d174b65UL, 0x64ce6d36522a96e4UL}},
	{{0x6171553cd385a729UL, 0x7af92da55164c6caUL,
	  0xfbd0e439144a5c5aUL, 0x9744f27a291576c1UL},
	 {0x607c63185d955ed1UL, 0x5377113ace236be6UL,
	  0x9b19348d2cf909d9UL, 0x71520cdd4f5ec18eUL}},
	{{0x45261e75d1b3bb5dUL, 0x1a0627fe8ddbdf10UL,
	  0xc7197ac318a57e32UL, 0xfce636d82d326ccaUL},
	 {0xc54ac12a2ea40061UL, 0xb1fad88512f318c7UL,
	  0xea8bafee4f7d05f9UL, 0xf433b71476cd5ba6UL}},
	{{0xec5e5cc77d702e80UL, 0x310eefc5a8ef02d3UL,
	  0xfc8455ac64f07b5bUL, 0x49e1d8268c40a254UL},
	 {0x5c576ae2a0879d1eUL, 0xec4e52daa25ec098UL,
	  0xbbced3dd9adb6e80UL, 0xbd41dfa223c408d3UL}},
	{{0x4c8b876b30f0681bUL, 0x1b635ae91b763543UL,
	  0xb36c8605c125c12cUL, 0x90cd1070bca1ea11UL},
	 {0xbbadcdb832417470UL, 0xcdd185a67f527dbUL,
	  0x1f972bfa5b50054UL, 0x6006e9875bee1982UL}},
	{{0x92c6c46e58b1ff29UL, 0x5c30d98905b0500bUL,
	  0x268cb82b3a9a0269UL, 0xcb20f1d40743dd0aUL},
	 {0xc244224af18f9a55UL, 0x36e32bfc72b298aUL,
	  0x35b032e256898e8eUL, 0x6c3c17dfbbaee0b2UL}},
	{{0x5738fcae12a99d2cUL, 0x4dcbf645f9a6efa2UL,
	  0xc63dd4ebe452f126UL, 0x462cb8cf1bd2f110UL},
	 {0xcefdb215df85cbf6UL, 0x6237fc5f24cd959UL,
	  0xfe158f415720a5f7UL, 0xc5c768fa7ba270a0UL}},
	{{0xbe3b93c77f8c6a16UL, 0xa111691c1e7eeb97UL,
	  0xc20662a7f831c143UL, 0xa8d5b1284bad54ebUL},
	 {0xf9e1d4c226e900b3UL, 0x8f58482e0231b6b4UL,
	  0xff6f737b0b3c2fa3UL, 0x3592deba1af5207eUL}},
	{{0x929a3b1548c60096UL, 0x3a5e28451ed1f604UL,
	  0x7c6a713ef6889ea7UL, 0x44544057e7b579fcUL},
	 {0x87130f8c4cdca524UL, 0x41d1c96caae8c04fUL,
	  0x3c1f415da6033d7eUL, 0xfcd2940b5ae7dbd3UL}},
	{{0xd93f027635b3656aUL, 0x74630cc7e6bc9a10UL,
	  0xe82325c5b932adabUL, 0xd82f31d9420770afUL},
	 {0x30b4df4ba5ece08cUL, 0xa0b3b51e32f2aa4aUL,
	  0x2b3a340817249a2aUL, 0x38f163aa1e6fd40UL}},
	{{0x422183685a1949b7UL, 0xbf74f78effa82c56UL,
	  0x57d63fae4545dbf6UL, 0xf1cf58926b0cf9b6UL},
	 {0xc2a0ad3426087c01UL, 0xf4e4d1fe0c930f68UL,
	  0x75e60572f763282cUL, 0x939e06baa3667f6fUL}},
	{{0x95cf1ca078d80ecbUL, 0x27ea1d59d11127ebUL,
	  0x96c89c5a99300fc2UL, 0xa99e00e002b3d55aUL},
	 {0x59e766fe84e7c072UL, 0xdb5f4f67bf72aba1UL,
	  0xd629057dfb33097dUL, 0xdff379e724588385UL}},
	{{0x45226040a8a370efUL, 0xf7104cec7a8b955aUL,
	  0x5ab4cf5f97124479UL, 0xce0b469c73cfd499UL},
	 {0xb51056c8e433e07bUL, 0xc4a6379ca1d6e672UL,
	  0x9921fcea45811df9UL, 0x23997e13e2db10e5UL}},
	{{0x3c6887d457b77133UL, 0x5fc726c31324f743UL,
	  0x61e02b60b4416b49UL, 0xad9ecce8f451d44fUL},
	 {0x7d8d52af4d9af768UL, 0x121b624c33626482UL,
	  0xbfbace131f05a7a5UL, 0x4c8cdb1e081513f6UL}},
	{{0x2c185c894b5e7018UL, 0x41d56ef8036c4cdbUL,
	  0xb278f0bdb9f6a6f7UL, 0x81394fe4bf1e1d35UL},
	 {0x39eb6488313ca827UL, 0x8542546d89b397f4UL,
	  0xa50b02ab0c922ccbUL, 0x46c0e7ca601067c0UL}},
	{{0xb017c38ad5a60665UL, 0xc9467b0575e88ea6UL,
	  0xa1f30d0f6f7875f8UL, 0x6c509286d4d52601UL},
	 {0xd1a5fb7c1f2e45f0UL, 0x5ff49a6b13401739UL,
	  0x4a4c26bb87fa69e2UL, 0x214eaccb6b6acc99UL}},
	{{0x99c02786925f1bcfUL, 0x4c4f91f35be1197fUL,
	  0x4d0a537765647440UL, 0xf4917bee225a8b2cUL},
	 {0xfa755a6b759767c2UL, 0x74ff7812d46f4804UL,
	  0x951140c7cdeedfd4UL, 0x6d00e5989380f1c5UL}},
	{{0x1a20a3700bb76779UL, 0x111ce0e1306978edUL,
	  0x759480974ac022c4UL, 0xb645f91b43655cb0UL},
	 {0x5bcf539f12cd92b0UL, 0x2137a9373a757338UL,
	  0xead461a2e36ae9a7UL, 0xe1a101da12cf530eUL}},
	{{0xd5debc9acd528b04UL, 0x625f31b81b786569UL,
	  0x2d3179679fa42b4dUL, 0xc7ddc4abaebc9b0dUL},
	 {0x315918e7b53cbc38UL, 0xd5c518ddccd2550eUL,
	  0x2ef47ccbe5aa733cUL, 0xf300d8dec28e171eUL}},
	{{0xd65c0764d5c95c8dUL, 0xe11f88211721da03UL,
	  0x4e9ecd19b9760799UL, 0x6b94ad8465e5431UL},
	 {0xee764ddf1bea72e0UL, 0x36462bd1b211aee1UL,
	  0x436d7a522f36fb4eUL, 0xf755f660652e7f00UL}},
	{{0x51ad6c572e769094UL, 0x4c90638f28b20fbcUL,
	  0xe55fbaf589b9b68dUL, 0x31bb4fc17405f739UL},
	 {0xaa157461686f057eUL, 0x3b10a8b54ae16adfUL,
	  0xc3e983b107605f1bUL, 0xe3b13e088d413930UL}},
	{{0x85837648a2d942a8UL, 0x84e0fa3fa22abe50UL,
	  0x5bb2a97b3f897130UL, 0x6bfb07c6c763182cUL},
	 {0x605895c6b1686c8fUL, 0x6014326c5279f0b4UL,
	  0x76e751417051c4a1UL, 0xe69c8a3613f25022UL}},
	{{0x98bbe4b018053678UL, 0xcb297c10f426f786UL,
	  0xb5841fa238ea1ef3UL, 0xac1b6cb44bb34022UL},
	 {0x6059f09f4618e123UL, 0x62575192a66bf193UL,
	  0xc529cf799af6d75dUL, 0xcab819ed1a4b66fbUL}},
	{{0xcbd88b2e1da1b1d6UL, 0x7b87d24bc27b1e7cUL,
	  0x3d7743980c3b0b1dUL, 0x6910d00af86a7731UL},
	 {0xab22c0bcdd8a50acUL, 0xa711161186d5b8b2UL,
	  0x998e16b2ccfb442dUL, 0x45e46a3c1f29a772UL}},
	{{0x7a58240d2d16bcb7UL, 0x1e919fc3735406f1UL,
	  0xa7f9f8fe66f42da8UL, 0x8bb9df269a32bdd9UL},
	 {0x66ceb32e2ee5701eUL, 0xb1c63fc3e6d2a65UL,
	  0x919abf7ba841114aUL, 0x1fc1632045b20c63UL}},
	{{0xd1d2098070adc81cUL, 0xc8b2dda7960a6585UL,
	  0xdd183c832e7b4dc2UL, 0xf656144fa4664c88UL},
	 {0x66dd8d864e99242bUL, 0x9c9dee9d78e0dd46UL,
	  0x2ca7943666760073UL, 0xe97e38b820d638ceUL}},
	{{0x77d30c0ec6fb151aUL, 0x449f5e48971ab9b7UL,
	  0xcc748405e83d22e3UL, 0x9162b379b24ca275UL},
	 {0xd22731394b19fd36UL, 0x70cc4b6bda82a01UL,
	  0x669feb9ac9747b7eUL, 0x723a6967ab9f91c0UL}},
	{{0xae2cf87db33cf553UL, 0xc50caddaa6b4c27cUL,
	  0xc534b887e95e0decUL, 0xa2074157bd82cec7UL},
	 {0xf3c96d24e247b7faUL, 0x87f4fb64fd7dcb2eUL,
	  0x3fba3a3e7d286ec2UL, 0x2a278df291a9195bUL}},
	{{0x6ac340a89b25d403UL, 0xe42fcef60472f36eUL,
	  0xa70637cddcfaea04UL, 0xa307fe977912171aUL},
	 {0xb9975a732fcd396fUL, 0x875e1667a9019979UL,
	  0x7be849940e736a92UL, 0xd5ac811386c989faUL}},
	{{0xe94ae5cca9de6e6fUL, 0xa809c530e02c002bUL,
	  0xf8613a85d0bf0cf6UL, 0x7bbb3a049b5056aUL},
	 {0x2f384bdc1cc0c289UL, 0xf07e08ad51776494UL,
	  0x8544b598979c0f51UL, 0x20404024122d9076UL}},
	{{0xd32ef27df303c9a3UL, 0x7a11c23dd7524e61UL,
	  0x5e02cec26c1e9848UL, 0xd032291f60453fb4UL},
	 {0x1be2de558b6266d9UL, 0x36fbe4235d2bcf0eUL,
	  0xf6820f29a79976d4UL, 0x9eda119ef6e30808UL}}
};
static DEFINE_PER_CPU(EcpXY, combT[W_SZ]);
static DEFINE_PER_CPU(TmpEcpPoint, combT_tmp[W_SZ]);

/**
 * Safe conditional assignment X = Y if @assign is 1.
 *
 * This function avoids leaking any information about whether the assignment was
 * done or not (the above code may leak information through branch prediction
 * and/or memory access patterns analysis). Leaking information about the
 * respective sizes of X and Y is ok however.
 */
static void
ecp256_safe_cond_assign(TlsMpi *X, const TlsMpi *Y, unsigned char assign)
{
	static const unsigned short s_masks[2] = {0, 0xffff};
	static const unsigned long l_masks[2] = {0, 0xffffffffffffffffUL};

	unsigned long *x = MPI_P(X), *y = MPI_P(Y);
	unsigned short s_mask;
	unsigned long l_mask;

	BUG_ON(X->used > G_LIMBS || Y->used > G_LIMBS);
	BUG_ON(X->limbs < Y->used);

	s_mask = s_masks[assign];
	l_mask = l_masks[assign];

	X->s ^= (X->s ^ Y->s) & s_mask;
	X->used ^= (X->used ^ Y->used) & s_mask;

	x[0] ^= (x[0] ^ y[0]) & l_mask;
	x[1] ^= (x[1] ^ y[1]) & l_mask;
	x[2] ^= (x[2] ^ y[2]) & l_mask;
	x[3] ^= (x[3] ^ y[3]) & l_mask;
}

/*
 * Fast mod-p functions expect their argument to be in the 0..p^2 range.
 *
 * In order to guarantee that, we need to ensure that operands of
 * multiplication are in the 0..p range. So, after each operation we will
 * bring the result back to this range.
 *
 * The following macros are shortcuts for doing that.
 */

/*
 * Reduce a TlsMpi mod p in-place, to use after ttls_mpi_sub_mpi
 * N->s < 0 is a very fast test, which fails only if N is 0
 */
static inline void
MOD_SUB(TlsMpi *N)
{
	while ((N)->s < 0 && ttls_mpi_cmp_int(N, 0))
		ttls_mpi_add_mpi(N, N, &G.P);
}

/*
 * Reduce a TlsMpi mod p in-place, to use after ttls_mpi_add_mpi().
 * We known P, N and the result are positive, so sub_abs is correct, and
 * a bit faster.
 */
static inline void
MOD_ADD(TlsMpi *N)
{
	while (ttls_mpi_cmp_mpi(N, &G.P) >= 0)
		ttls_mpi_sub_abs(N, N, &G.P);
}

/*
 * For curves in short Weierstrass form, we do all the internal operations in
 * Jacobian coordinates.
 *
 * For multiplication, we'll use a comb method with coutermeasueres against
 * SPA, hence timing attacks.
 */

static void
ecp256_mul_mod(TlsMpi *X, const TlsMpi *A, const TlsMpi *B)
{
	BUG_ON(X->limbs < G_LIMBS);
	BUG_ON(A->limbs < G_LIMBS || B->limbs < G_LIMBS);
	BUG_ON(A->s < 0 || B->s < 0);
	BUG_ON(A->used != G_LIMBS || B->used != G_LIMBS);

	mpi_mul_x86_64_4(MPI_P(X), MPI_P(A), MPI_P(B));

	mpi_fixup_used(X, G_LIMBS * 2);
	X->s = A->s * B->s;

	ecp_mod_p256_x86_64(MPI_P(X), X->used);
	mpi_fixup_used(X, G_LIMBS);
}

static void
ecp256_sqr_mod(TlsMpi *X, const TlsMpi *A)
{
	BUG_ON(X->limbs < G_LIMBS);
	BUG_ON(A->limbs < G_LIMBS);
	BUG_ON(A->s < 0);
	BUG_ON(A->used != G_LIMBS);

	mpi_sqr_x86_64_4(MPI_P(X), MPI_P(A));

	mpi_fixup_used(X, G_LIMBS * 2);
	X->s = 1;

	ecp_mod_p256_x86_64(MPI_P(X), X->used);
	mpi_fixup_used(X, G_LIMBS);
}

/*
 * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
 * Cost: 1N := 1I + 3M + 1S
 */
static int
ecp256_normalize_jac(TlsEcpPoint *pt)
{
	TlsMpi *Zi, *ZZi;

	if (!ttls_mpi_cmp_int(&pt->Z, 0))
		return 0;

	Zi = ttls_mpi_alloc_stack_init(G_LIMBS);
	ZZi = ttls_mpi_alloc_stack_init(G_LIMBS * 2);

	/* X = X / Z^2  mod p */
	ttls_mpi_inv_mod(Zi, &pt->Z, &G.P);
	ecp256_sqr_mod(ZZi, Zi);
	ecp256_mul_mod(&pt->X, &pt->X, ZZi);

	/* Y = Y / Z^3  mod p */
	ecp256_mul_mod(&pt->Y, &pt->Y, ZZi);
	ecp256_mul_mod(&pt->Y, &pt->Y, Zi);

	/* Z = 1 */
	ttls_mpi_lset(&pt->Z, 1);

	return 0;
}

static void
ecp256_normalize_jac_many(TlsEcpPoint *T[], size_t t_len)
{
#define __INIT_C(i)							\
do {									\
	c[i].s = 1;							\
	c[i].used = 0;							\
	c[i].limbs = G_LIMBS * 2;					\
	c[i]._off = (unsigned long)p_limbs - (unsigned long)(c + i);	\
	p_limbs += G_LIMBS * 2;						\
} while (0)

	int i;
	unsigned long *p_limbs;
	TlsMpi *u, *Zi, *ZZi, *c;

	// TODO #1064 move the allocation to the memory profile.
	c = ttls_mpool_alloc_stack((sizeof(TlsMpi) + G_LIMBS * 2 * CIL) * t_len);
	u = ttls_mpi_alloc_stack_init(G_LIMBS * 2);
	Zi = ttls_mpi_alloc_stack_init(G_LIMBS * 2);
	ZZi = ttls_mpi_alloc_stack_init(G_LIMBS * 2);
	bzero_fast(c, sizeof(TlsMpi) * t_len);
	p_limbs = (unsigned long *)&c[t_len];

	/* c[i] = Z_0 * ... * Z_i */
	__INIT_C(0);
	ttls_mpi_copy_alloc(&c[0], &T[0]->Z, false);
	for (i = 1; i < t_len; i++) {
		__INIT_C(i);
		ecp256_mul_mod(&c[i], &c[i - 1], &T[i]->Z);
	}

	/* u = 1 / (Z_0 * ... * Z_n) mod P */
	ttls_mpi_inv_mod(u, &c[t_len - 1], &G.P);

	for (i = t_len - 1; i >= 0; i--) {
		/*
		 * Zi = 1 / Z_i mod p
		 * u = 1 / (Z_0 * ... * Z_i) mod P
		 */
		if (!i) {
			ttls_mpi_copy(Zi, u);
		} else {
			ecp256_mul_mod(Zi, u, &c[i - 1]);
			ecp256_mul_mod(u, u, &T[i]->Z);
		}

		/* proceed as in normalize(). */
		ecp256_sqr_mod(ZZi, Zi);
		ecp256_mul_mod(&T[i]->X, &T[i]->X, ZZi);
		ecp256_mul_mod(&T[i]->Y, &T[i]->Y, ZZi);
		ecp256_mul_mod(&T[i]->Y, &T[i]->Y, Zi);
		/*
		 * At the moment Z coordinate stores a garbage, so free
		 * it now and treat as 1 on subsequent processing.
		 */
		ttls_mpi_reset(&T[i]->Z);
	}

	ttls_mpi_pool_cleanup_ctx((unsigned long)c, false);
#undef __INIT_C
}

/**
 * Conditional point inversion: Q -> -Q = (Q.X, -Q.Y, Q.Z) without leak.
 * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid.
 */
static void
ecp256_safe_invert_jac(TlsEcpPoint *Q, unsigned char inv)
{
	unsigned char nonzero;
	TlsMpi *mQY = ttls_mpi_alloc_stack_init(G_LIMBS);

	/* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */
	ttls_mpi_sub_mpi(mQY, &G.P, &Q->Y);
	nonzero = !!ttls_mpi_cmp_int(&Q->Y, 0);

	ecp256_safe_cond_assign(&Q->Y, mQY, inv & nonzero);
}

/**
 * Point doubling R = 2 P, Jacobian coordinates [8, "dbl-1998-cmo-2"].
 *
 * We follow the variable naming fairly closely. The formula variations that
 * trade a MUL for a SQR (plus a few ADDs) aren't useful as our bignum
 * implementation doesn't distinguish squaring.
 *
 * Standard optimizations are applied when curve parameter A is one of {0, -3}.
 *
 * Cost: 1D := 3M + 4S	(A ==  0)
 *	 4M + 4S	(A == -3)
 *	 3M + 6S + 1a	otherwise
 */
static int
ecp256_double_jac(TlsEcpPoint *R, const TlsEcpPoint *P)
{
	TlsMpi M, S, T, U;

	ttls_mpi_alloca_init(&M, G_LIMBS * 2);
	ttls_mpi_alloca_init(&S, G_LIMBS * 2);
	ttls_mpi_alloca_init(&T, G_LIMBS * 2);
	ttls_mpi_alloca_init(&U, G_LIMBS * 2);

	/* M = 3(X + Z^2)(X - Z^2) */
	if (likely(ttls_mpi_cmp_int(&P->Z, 1)))
		ecp256_sqr_mod(&S, &P->Z);
	else
		ttls_mpi_lset(&S, 1);
	ttls_mpi_add_mpi(&T, &P->X, &S);
	MOD_ADD(&T);
	ttls_mpi_sub_mpi(&U, &P->X, &S);
	MOD_SUB(&U);
	ecp256_mul_mod(&S, &T, &U);
	ttls_mpi_copy_alloc(&M, &S, false);
	ttls_mpi_shift_l(&M, 1);
	ttls_mpi_add_mpi(&M, &M, &S);
	MOD_ADD(&M);

	/* S = 4 * X * Y^2 */
	ecp256_sqr_mod(&T, &P->Y);
	ttls_mpi_shift_l(&T, 1);
	MOD_ADD(&T);
	ecp256_mul_mod(&S, &P->X, &T);
	ttls_mpi_shift_l(&S, 1);
	MOD_ADD(&S);

	/* U = 8.Y^4 */
	ecp256_sqr_mod(&U, &T);
	ttls_mpi_shift_l(&U, 1);
	MOD_ADD(&U);

	/* T = M^2 - 2 * S */
	ecp256_sqr_mod(&T, &M);
	ttls_mpi_sub_mpi(&T, &T, &S);
	MOD_SUB(&T);
	ttls_mpi_sub_mpi(&T, &T, &S);
	MOD_SUB(&T);

	/* S = M(S - T) - U */
	ttls_mpi_sub_mpi(&S, &S, &T);
	MOD_SUB(&S);
	ecp256_mul_mod(&S, &S, &M);
	ttls_mpi_sub_mpi(&S, &S, &U);
	MOD_SUB(&S);

	/* U = 2 * Y * Z */
	if (likely(ttls_mpi_cmp_int(&P->Z, 1)))
		ecp256_mul_mod(&U, &P->Y, &P->Z);
	else
		ttls_mpi_copy(&U, &P->Y);
	ttls_mpi_shift_l(&U, 1);
	MOD_ADD(&U);

	ttls_mpi_copy(&R->X, &T);
	ttls_mpi_copy(&R->Y, &S);
	ttls_mpi_copy(&R->Z, &U);

	return 0;
}

/*
 * Addition: R = P + Q, mixed affine-Jacobian coordinates (GECC 3.22)
 *
 * #TODO #1064: the implementation uses formula [8, "madd-2008-g"] and I'm not
 * sure if it's the most efficient one - [9] refernces another formula.
 *
 * The coordinates of Q must be normalized (= affine),
 * but those of P don't need to. R is not normalized.
 *
 * Special cases: (1) P or Q is zero, (2) R is zero, (3) P == Q.
 * None of these cases can happen as intermediate step in ecp_mul_comb():
 * - at each step, P, Q and R are multiples of the base point, the factor
 *   being less than its order, so none of them is zero;
 * - Q is an odd multiple of the base point, P an even multiple,
 *   due to the choice of precomputed points in the modified comb method.
 * So branches for these cases do not leak secret information.
 *
 * We accept Q->Z being unset (saving memory in tables) as meaning 1.
 *
 * Cost: 1A := 8M + 3S (same as Chudnovsky-Affine time, GECC 3.2.2).
 */
static int
ecp256_add_mixed(TlsEcpPoint *R, const TlsEcpPoint *P, const TlsEcpPoint *Q)
{
	TlsMpi T1, T2, T3, T4, X, Y, Z;

	/* Trivial cases: P == 0 or Q == 0 (case 1). */
	if (!ttls_mpi_cmp_int(&P->Z, 0)) {
		ttls_ecp_copy(R, Q);
		return 0;
	}
	if (!ttls_mpi_empty(&Q->Z)) {
		if (!ttls_mpi_cmp_int(&Q->Z, 0)) {
			ttls_ecp_copy(R, P);
			return 0;
		}
		/* Make sure Q coordinates are normalized. */
		if (ttls_mpi_cmp_int(&Q->Z, 1))
			return -EINVAL;
	}

	ttls_mpi_alloca_init(&T1, G_LIMBS * 2);
	ttls_mpi_alloca_init(&T2, G_LIMBS * 2);
	ttls_mpi_alloca_init(&T3, G_LIMBS * 2);
	ttls_mpi_alloca_init(&T4, G_LIMBS * 2);
	ttls_mpi_alloca_init(&X, G_LIMBS * 2);
	ttls_mpi_alloca_init(&Y, G_LIMBS * 2);
	ttls_mpi_alloca_init(&Z, G_LIMBS * 2);

	if (unlikely(!ttls_mpi_cmp_int(&P->Z, 1))) {
		/* Relatively rare case, ~1/60. */
		ttls_mpi_sub_mpi(&T1, &Q->X, &P->X);
		MOD_SUB(&T1);
		ttls_mpi_sub_mpi(&T2, &Q->Y, &P->Y);
		MOD_SUB(&T2);
	} else {
		ecp256_sqr_mod(&T1, &P->Z);
		ecp256_mul_mod(&T2, &T1, &P->Z);
		ecp256_mul_mod(&T1, &T1, &Q->X);
		ecp256_mul_mod(&T2, &T2, &Q->Y);
		ttls_mpi_sub_mpi(&T1, &T1, &P->X);
		MOD_SUB(&T1);
		ttls_mpi_sub_mpi(&T2, &T2, &P->Y);
		MOD_SUB(&T2);
	}

	/* Special cases (2) and (3) */
	if (!ttls_mpi_cmp_int(&T1, 0)) {
		if (!ttls_mpi_cmp_int(&T2, 0))
			return ecp256_double_jac(R, P);
		ttls_ecp_set_zero(R);
		return 0;
	}

	if (unlikely(!ttls_mpi_cmp_int(&P->Z, 1)))
		ttls_mpi_copy_alloc(&Z, &T1, false);
	else
		ecp256_mul_mod(&Z, &P->Z, &T1);
	ecp256_sqr_mod(&T3, &T1);
	ecp256_mul_mod(&T4, &T3, &T1);
	ecp256_mul_mod(&T3, &T3, &P->X);
	ttls_mpi_copy_alloc(&T1, &T3, false);
	ttls_mpi_shift_l(&T1, 1);
	MOD_ADD(&T1);
	ecp256_sqr_mod(&X, &T2);
	ttls_mpi_sub_mpi(&X, &X, &T1);
	MOD_SUB(&X);
	ttls_mpi_sub_mpi(&X, &X, &T4);
	MOD_SUB(&X);
	ttls_mpi_sub_mpi(&T3, &T3, &X);
	MOD_SUB(&T3);
	ecp256_mul_mod(&T3, &T3, &T2);
	ecp256_mul_mod(&T4, &T4, &P->Y);
	ttls_mpi_sub_mpi(&Y, &T3, &T4);
	MOD_SUB(&Y);

	/* Resulting coorinates are twice smaller than the temporary MPIs. */
	ttls_mpi_copy(&R->X, &X);
	ttls_mpi_copy(&R->Y, &Y);
	ttls_mpi_copy(&R->Z, &Z);

	return 0;
}

/*
 * Randomize jacobian coordinates:
 * (X, Y, Z) -> (l^2 X, l^3 Y, l Z) for random l
 * This is sort of the reverse operation of ecp256_normalize_jac().
 *
 * This countermeasure was first suggested in [2]. See also the recommendation
 * for SPA and DPA attacks prevention in J.Coron, "Resistance against
 * Differential Power Analysis for Elliptic Curve Cryptosystems".
 */
static int
ecp256_randomize_jac(TlsEcpPoint *pt)
{
	TlsMpi l, ll;
	size_t p_size = G_LIMBS * CIL;
	int count = 0;

	ttls_mpi_alloca_init(&l, p_size);
	ttls_mpi_alloca_init(&ll, p_size * 2);

	/* Generate l such that 1 < l < p */
	do {
		ttls_mpi_fill_random(&l, p_size);

		while (ttls_mpi_cmp_mpi(&l, &G.P) >= 0)
			ttls_mpi_shift_r(&l, 1);

		if (count++ > 10)
			return TTLS_ERR_ECP_RANDOM_FAILED;
	} while (ttls_mpi_cmp_int(&l, 1) <= 0);

	/* Z = l * Z */
	if (likely(ttls_mpi_cmp_int(&pt->Z, 1)))
		ecp256_mul_mod(&pt->Z, &pt->Z, &l);
	else
		ttls_mpi_copy_alloc(&pt->Z, &l, false);

	/* X = l^2 * X */
	ecp256_sqr_mod(&ll, &l);
	ecp256_mul_mod(&pt->X, &pt->X, &ll);

	/* Y = l^3 * Y */
	ecp256_mul_mod(&ll, &ll, &l);
	ecp256_mul_mod(&pt->Y, &pt->Y, &ll);

	return 0;
}

/*
 * Compute the representation of m that will be used with our comb method.
 *
 * The basic comb method is described in GECC 3.44 for example. We use a
 * modified version that provides resistance to SPA by avoiding zero
 * digits in the representation as in [3]. We modify the method further by
 * requiring that all K_i be odd, which has the small cost that our
 * representation uses one more K_i, due to carries.
 *
 * Also, for the sake of compactness, only the seven low-order bits of x[i]
 * are used to represent K_i, and the msb of x[i] encodes the sign (s_i in
 * the paper): it is set if and only if s_i == -1;
 *
 * Calling conventions:
 * - x is an array of size d + 1
 * - w is the size, ie number of teeth, of the comb, and must be between
 *   2 and 7 (in practice, between 2 and TTLS_ECP_WINDOW_ORDER)
 * - m is the MPI, expected to be odd and such that bitlength(m) <= w * d
 *   (the result will be incorrect if these assumptions are not satisfied)
 */
static void
ecp256_comb_fixed(unsigned char x[], size_t d, unsigned char w, const TlsMpi *m)
{
	size_t i, j, b, bits = m->used * BIL;
	unsigned long *p = MPI_P(m);
	unsigned char c, cc, adjust;

	bzero_fast(x, d + 1);

	/* First get the classical comb values (except for x_d = 0) */
	for (i = 0; i < d; i++)
		for (j = 0; j < w; j++) {
			b = i + d * j;
			if (unlikely(b >= bits))
				break;
			x[i] |= ((p[b >> BSHIFT] >> (b & BMASK)) & 1) << j;
		}

	/* Now make sure x_1 .. x_d are odd */
	for (c = 0, i = 1; i <= d; i++) {
		/* Add carry and update it */
		cc = x[i] & c;
		x[i] = x[i] ^ c;
		c = cc;

		/* Adjust if needed, avoiding branches */
		adjust = 1 - (x[i] & 1);
		c |= x[i] & (x[i - 1] * adjust);
		x[i] = x[i] ^ (x[i - 1] * adjust);
		x[i - 1] |= adjust << 7;
	}
}

/*
 * Precompute points for the comb method
 *
 * If i = i_{w-1} ... i_1 is the binary representation of i, then
 * T[i] = i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + P
 *
 * T must be able to hold 2^{w - 1} elements
 *
 * Cost: d(w-1) D + (2^{w-1} - 1) A + 1 N(w-1) + 1 N(2^{w-1} - 1)
 */
static int
ecp256_precompute_comb(const TlsEcpPoint *P)
{
	int i, j, k;
	TlsEcpPoint *cur, *TT[W_SZ];
	TmpEcpPoint *T = *this_cpu_ptr(&combT_tmp);
	EcpXY *Txy = *this_cpu_ptr(&combT);

	if (unlikely(!T[0].p.X._off)) {
		for (i = 0; i < W_SZ; ++i) {
			T[i].p.X.limbs = G_LIMBS * 2;
			T[i].p.X._off = (long)T[i].x - (long)&T[i].p.X;
			T[i].p.Y.limbs = G_LIMBS * 2;
			T[i].p.Y._off = (long)T[i].y - (long)&T[i].p.Y;
			T[i].p.Z.limbs = G_LIMBS;
			T[i].p.Z._off = (long)T[i].z - (long)&T[i].p.Z;
		}
	}

	/*
	 * Set T[0] = P and T[2^{i-1}] = 2^{di} P for i = 1 .. w-1
	 * (this is not the final value).
	 */
	ttls_ecp_copy(&T[0].p, P);

	for (k = 0, i = 1; i < W_SZ; i <<= 1) {
		cur = &T[i].p;
		ttls_ecp_copy(cur, &T[i >> 1].p);
		for (j = 0; j < D; j++)
			/*
			 * cur->Z will be non-1 after the operation.
			 *
			 * TODO #1064 use repeated doubling optimization.
			 * E.g. see sp_256_proj_point_dbl_n_store_avx2_4() and
			 * sp_256_proj_point_dbl_n_avx2_4() from WolfSSL.
			 */
			MPI_CHK(ecp256_double_jac(cur, cur));

		TT[k++] = cur;
	}
	ecp256_normalize_jac_many(TT, k);

	/*
	 * Compute the remaining ones using the minimal number of additions
	 * Be careful to update T[2^l] only after using it!
	 */
	for (k = 0, i = 1; i < W_SZ; i <<= 1) {
		j = i;
		while (j--) {
			MPI_CHK(ecp256_add_mixed(&T[i + j].p, &T[j].p, &T[i].p));
			TT[k++] = &T[i + j].p;
		}
	}
	ecp256_normalize_jac_many(TT, k);

	for (i = 0; i <= k; i++) {
		memcpy_fast(Txy[i].x, MPI_P(&T[i].p.X), G_LIMBS * CIL);
		memcpy_fast(Txy[i].y, MPI_P(&T[i].p.Y), G_LIMBS * CIL);
	}

	return 0;
}

/*
 * Select precomputed point: R = sign(i) * T[ abs(i) / 2 ]
 */
static void
ecp256_select_comb(TlsEcpPoint *R, const EcpXY T[], unsigned char t_len,
		   unsigned char i)
{
	static const unsigned long l_masks[2] = {0, 0xffffffffffffffffUL};
	unsigned long *rx = MPI_P(&R->X), *ry = MPI_P(&R->Y);
	unsigned char ii, j;

	R->X.s = 1;
	R->X.used = G_LIMBS;
	R->Y.s = 1;
	R->Y.used = G_LIMBS;

	/* Ignore the "sign" bit and scale down */
	ii =  (i & 0x7Fu) >> 1;

	/* Read the whole table to thwart cache-based timing attacks */
	for (j = 0; j < t_len; j++) {
		const unsigned long mask = l_masks[j == ii];

		rx[0] ^= (rx[0] ^ T[j].x[0]) & mask;
		rx[1] ^= (rx[1] ^ T[j].x[1]) & mask;
		rx[2] ^= (rx[2] ^ T[j].x[2]) & mask;
		rx[3] ^= (rx[3] ^ T[j].x[3]) & mask;

		ry[0] ^= (ry[0] ^ T[j].y[0]) & mask;
		ry[1] ^= (ry[1] ^ T[j].y[1]) & mask;
		ry[2] ^= (ry[2] ^ T[j].y[2]) & mask;
		ry[3] ^= (ry[3] ^ T[j].y[3]) & mask;
	}

	/* Safely invert result if i is "negative" */
	ecp256_safe_invert_jac(R, i >> 7);
}

/*
 * Core multiplication algorithm for the (modified) comb method.
 * This part is actually common with the basic comb method (GECC 3.44)
 *
 * Cost: d A + d D + 1 R
 */
static int
ecp256_mul_comb_core(TlsEcpPoint *R, const EcpXY T[], size_t t_len,
		     const unsigned char x[], size_t d, bool rnd)
{
	TlsEcpPoint *Txi;
	size_t i;

	ttls_ecp_point_tmp_alloc_init(Txi, G_LIMBS, G_LIMBS, 0);
	ttls_mpi_alloc(&R->X, G_LIMBS * 2);
	ttls_mpi_alloc(&R->Y, G_LIMBS * 2);
	ttls_mpi_alloc(&R->Z, G_LIMBS + 1);

	/*
	 * We operate with precomputed table which is significantly smaller
	 * than L1d cache - for secp256 and w=7:
	 *
	 *	(sizeof(ECP)=(2 * 32)) * (1 << (w - 1)) = 4096
	 *
	 * For w=8 this would be:
	 *
	 *	(sizeof(ECP)=(2 * 32)) * (1 << (w - 1)) = 8192
	 *
	 * Also there is no preemption and point doubling and addition
	 * aren't memory hungry, so once read T resides in L1d cache and
	 * we can address T directly without sacrificing safety against SCAs.
	 * FIXME in hyperthreading mode an aggressive sibling thread can evict
	 * the precomputed table.
	 *
	 * Start with a non-zero point and randomize its coordinates.
	 *
	 * TODO #1064: only X and Y coordinates are used here.
	 * TODO #1064: 5. AVX2 - 4 points in parallel in OpenSSL - learn more
	 */
	i = d;
	ecp256_select_comb(R, T, t_len, x[i]);
	ttls_mpi_lset(&R->Z, 1);
	if (rnd)
		MPI_CHK(ecp256_randomize_jac(R));

	while (i--) {
		unsigned char ii = (x[i] & 0x7Fu) >> 1;

		/*
		 * TODO #1064 use repeated doubling optimization.
		 * E.g. see sp_256_proj_point_dbl_n_store_avx2_4() and
		 * sp_256_proj_point_dbl_n_avx2_4() from WolfSSL.
		 */
		MPI_CHK(ecp256_double_jac(R, R));

		Txi->X.s = 1;
		Txi->X.used = G_LIMBS;
		memcpy_fast(MPI_P(&Txi->X), &T[ii].x, G_LIMBS * CIL);

		Txi->Y.s = 1;
		Txi->Y.used = G_LIMBS;
		memcpy_fast(MPI_P(&Txi->Y), &T[ii].y, G_LIMBS * CIL);

		ecp256_safe_invert_jac(Txi, x[i] >> 7);

		MPI_CHK(ecp256_add_mixed(R, R, Txi));
	}

	return 0;
}

/*
 * Multiplication R = m * P using the comb method.
 *
 * In order to prevent timing attacks, this function executes the exact same
 * sequence of (base field) operations for any valid m. It avoids any if-branch
 * or array index depending on the value of m.
 *
 * If @rng is true, the functions randomizes intermediate results in order to
 * prevent potential timing attacks targeting these results.
 *
 * TODO #1064: This function is used for unknown points only, i.e. the public
 * key Q from the peer in ECDHE exchange, so we see @P only once and there is
 * sense to cache computation results for the scalar (our secret) only.
 *
 * May allocate @R point on the stack, so while the function uses plenty of
 * memory we can't call ttls_mpi_pool_cleanup_ctx() here.
 *
 * TODO #1064: why wNAF isn't used? Is comb the most efficient method?
 * It seems WolfSSL's sp_256_ecc_mulmod_win_add_sub_avx2_4() also uses comb,
 * but with d=43 (w=6).
 * OpenSSL's ecp_nistz256_windowed_mul() use Booth windowed method.
 * It seems the both OpenSSL and WolfSSL don't use coordinates randomization.
 */
static int
ecp256_mul_comb(TlsEcpPoint *R, const TlsMpi *m, const TlsEcpPoint *P, bool rnd)
{
	/*
	 * Minimize the number of multiplications, that is minimize
	 * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil(bits / w)
	 * (see costs of the various parts, with 1S = 1M).
	 * TODO #1064 make sure that w size is the best one.
	 */
	static const size_t COMB_MAX_D = G_BITS / 2 + 1;

	unsigned char m_is_odd;
	TlsMpi *M, *mm;
	unsigned char k[COMB_MAX_D];

	M = ttls_mpi_alloc_stack_init(G_LIMBS);
	mm = ttls_mpi_alloc_stack_init(G_LIMBS);

	BUILD_BUG_ON(D >= COMB_MAX_D);

	MPI_CHK(ecp256_precompute_comb(P));

	/*
	 * Make sure M is odd (M = m or M = N - m, since N is odd)
	 * using the fact that m * P = - (N - m) * P
	 */
	m_is_odd = (ttls_mpi_get_bit(m, 0) == 1);
	ttls_mpi_copy(M, m);
	ttls_mpi_sub_mpi(mm, &G.N, m);
	ecp256_safe_cond_assign(M, mm, !m_is_odd);

	/* Go for comb multiplication, R = M * P */
	ecp256_comb_fixed(k, D, W, M);
	MPI_CHK(ecp256_mul_comb_core(R, *this_cpu_ptr(&combT), W_SZ, k, D, rnd));

	/* Now get m * P from M * P and normalize it. */
	ecp256_safe_invert_jac(R, !m_is_odd);
	MPI_CHK(ecp256_normalize_jac(R));

	return 0;
}

/**
 * The specialization for R = m * G.
 *
 * TODO #1064: Do we need coordinates randomization?
 */
static int
ecp256_mul_comb_g(TlsEcpPoint *R, const TlsMpi *m, bool rnd)
{
	static const size_t COMB_MAX_D = G_BITS / 2 + 1;

	unsigned char m_is_odd;
	TlsMpi *M, *mm;
	unsigned char k[COMB_MAX_D];

	BUILD_BUG_ON(G_D >= COMB_MAX_D);

	M = ttls_mpi_alloc_stack_init(G_LIMBS);
	mm = ttls_mpi_alloc_stack_init(G_LIMBS);

	/*
	 * Make sure M is odd (M = m or M = N - m, since N is odd)
	 * using the fact that m * P = - (N - m) * P
	 */
	m_is_odd = (ttls_mpi_get_bit(m, 0) == 1);
	ttls_mpi_copy(M, m);
	ttls_mpi_sub_mpi(mm, &G.N, m);
	ecp256_safe_cond_assign(M, mm, !m_is_odd);

	/* Go for comb multiplication, R = M * G */
	ecp256_comb_fixed(k, G_D, G_W, M);
	MPI_CHK(ecp256_mul_comb_core(R, combT_G, G_W_SZ, k, G_D, rnd));

	/* Now get m * G from M * G and normalize it. */
	ecp256_safe_invert_jac(R, !m_is_odd);
	MPI_CHK(ecp256_normalize_jac(R));

	return 0;
}

/**
 * R = m * P with shortcuts for m == 1 and m == -1.
 * NOT constant-time - ONLY for short Weierstrass!
 */
static int
ecp256_mul_shortcuts(TlsEcpPoint *R, const TlsMpi *m, const TlsEcpPoint *P)
{
	if (!ttls_mpi_cmp_int(m, 1)) {
		ttls_ecp_copy(R, P);
		return 0;
	}

	if (!ttls_mpi_cmp_int(m, -1)) {
		ttls_ecp_copy(R, P);
		if (ttls_mpi_cmp_int(&R->Y, 0))
			ttls_mpi_sub_mpi(&R->Y, &G.P, &R->Y);
		return 0;
	}

	return P ? ecp256_mul_comb(R, m, P, false)
		 : ecp256_mul_comb_g(R, m, false);
}

/*
 * Multiplication and addition of two points by integers: R = m * G + n * Q
 * In contrast to ttls_ecp_mul(), this function does not guarantee a constant
 * execution flow and timing - ther is no secret data, so we don't need to care
 * about SCAs.
 *
 * TODO #769: The algorithm is naive. The Shamir's trick and/or
 * multi-exponentiation (Bodo Möller, "Algorithms for multi-exponentiation")
 * should be used. See OpenSSL's ec_wNAF_mul() as the reference.
 */
static int
ecp256_muladd(TlsEcpPoint *R, const TlsMpi *m, const TlsEcpPoint *Q,
	      const TlsMpi *n)
{
	TlsEcpPoint *mP;

	mP = ttls_mpool_alloc_stack(sizeof(TlsEcpPoint));
	ttls_ecp_point_init(mP);

	MPI_CHK(ecp256_mul_shortcuts(mP, m, NULL));
	MPI_CHK(ecp256_mul_shortcuts(R, n, Q));
	MPI_CHK(ecp256_add_mixed(R, mP, R));
	MPI_CHK(ecp256_normalize_jac(R));

	return 0;
}

/**
 * Generate a keypair with configurable base point - SEC1 3.2.1:
 * generate d such that 1 <= n < N.
 */
int
ecp256_gen_keypair(TlsMpi *d, TlsEcpPoint *Q)
{
	int count = 0;

	/*
	 * Match the procedure given in RFC 6979 (deterministic ECDSA):
	 * - use the same byte ordering;
	 * - keep the leftmost bits bits of the generated octet string;
	 * - try until result is in the desired range.
	 * This also avoids any biais, which is especially important
	 * for ECDSA.
	 */
	do {
		ttls_mpi_fill_random(d, G_BITS / 8);

		/*
		 * Each try has at worst a probability 1/2 of failing
		 * (the msb has a probability 1/2 of being 0, and then
		 * the result will be < N), so after 30 tries failure
		 * probability is a most 2**(-30).
		 *
		 * For most curves, 1 try is enough with overwhelming
		 * probability, since N starts with a lot of 1s in
		 * binary, but some curves such as secp224k1 are
		 * actually very close to the worst case.
		 */
		if (WARN_ON_ONCE(++count > 10))
			return TTLS_ERR_ECP_RANDOM_FAILED;
	} while (!ttls_mpi_cmp_int(d, 0) || ttls_mpi_cmp_mpi(d, &G.N) >= 0);

	return ecp256_mul_comb_g(Q, d, true);
}

/*
 * Derive a suitable integer for the group from a buffer of length len
 * SEC1 4.1.3 step 5 aka SEC1 4.1.4 step 3
 */
static void
derive_mpi(TlsMpi *x, const unsigned char *buf, size_t blen)
{
	const size_t n_size = G_BITS / 8;
	const size_t use_size = blen > n_size ? n_size : blen;

	ttls_mpi_read_binary(x, buf, use_size);

	/* While at it, reduce modulo N */
	if (ttls_mpi_cmp_mpi(x, &G.N) >= 0)
		ttls_mpi_sub_mpi(x, x, &G.N);
}

/**
 * This function computes the ECDSA signature of a hashed message (SEC1 4.1.3)
 * and writes it to a buffer, serialized as defined in RFC 8422 5.4.
 * Obviously, compared to SEC1 4.1.3, we skip step 4 (hash message).
 *
 * The sig buffer must be at least twice as large as the size of the curve used,
 * plus 9. For example, 73 Bytes if a 256-bit curve is used. A buffer length of
 * TTLS_ECDSA_MAX_LEN is always safe.
 *
 * If the bitlength of the message hash is larger than the bitlength of the
 * group order, then the hash is truncated as defined in Standards for Efficient
 * Cryptography Group (SECG): SEC1 Elliptic Curve Cryptography, section 4.1.3,
 * step 5.
 *
 * This is the late phase of ServerKeyExchange, so no need to clear the mpool
 * stack at the end of the function.
 */
static int
ecp256_ecdsa_sign(const TlsMpi *d, const unsigned char *hash, size_t hlen,
		  unsigned char *sig, size_t *slen)
{
	int key_tries, sign_tries, blind_tries, n;
	TlsMpi *k, *e, *t, *r, *s;
	TlsEcpPoint *R;

	n = max_t(size_t, G_LIMBS + d->used, hlen / CIL);
	k = ttls_mpi_alloc_stack_init(G_LIMBS * 2);
	e = ttls_mpi_alloc_stack_init(n * 2);
	t = ttls_mpi_alloc_stack_init(G_LIMBS);
	r = ttls_mpi_alloc_stack_init(G_LIMBS);
	s = ttls_mpi_alloc_stack_init(n * 2);
	R = ttls_mpool_alloc_stack(sizeof(*R));
	ttls_ecp_point_init(R);
	ttls_mpi_alloc(&R->Z, G_LIMBS * 2);

	sign_tries = 0;
	do {
		/* Generate a suitable ephemeral keypair and set r = xR mod n */
		key_tries = 0;
		do {
			MPI_CHK(ecp256_gen_keypair(k, R));
			ttls_mpi_mod_mpi(r, &R->X, &G.N);

			if (key_tries++ > 10)
				return TTLS_ERR_ECP_RANDOM_FAILED;
		} while (!ttls_mpi_cmp_int(r, 0));

		/* Derive MPI from hashed message. */
		derive_mpi(e, hash, hlen);

		/*
		 * Generate a random value to blind inv_mod in next step,
		 * avoiding a potential timing leak.
		 */
		blind_tries = 0;
		do {
			ttls_mpi_fill_random(t, G_BITS / 8);

			/* See ttls_ecp_gen_keypair() */
			if (++blind_tries > 10)
				return TTLS_ERR_ECP_RANDOM_FAILED;
		} while (ttls_mpi_cmp_int(t, 1) < 0
			 || ttls_mpi_cmp_mpi(t, &G.N) >= 0);

		/* Compute s = (e + r * d) / k = t (e + rd) / (kt) mod n */
		ttls_mpi_mul_mpi(s, r, d);
		ttls_mpi_add_mpi(e, e, s);
		ttls_mpi_mul_mpi(e, e, t);
		ttls_mpi_mul_mpi(k, k, t);
		ttls_mpi_inv_mod(s, k, &G.N); // TODO #1064 hot spot
		ttls_mpi_mul_mpi(s, s, e);
		ttls_mpi_mod_mpi(s, s, &G.N);

		if (sign_tries++ > 10)
			return TTLS_ERR_ECP_RANDOM_FAILED;
	} while (!ttls_mpi_cmp_int(s, 0));

	return ecdsa_signature_to_asn1(r, s, sig, slen);
}

/*
 * Verify ECDSA signature of hashed message (SEC1 4.1.4)
 * Obviously, compared to SEC1 4.1.3, we skip step 2 (hash message).
 *
 * @buf		- the message hash;
 * @blen	- the length of the hash buf;
 * @Q		- the public key to use for verification;
 * @r		- the first integer of the signature;
 * @s		- the second integer of the signature.
 *
 * If the bitlength of the message hash is larger than the bitlength of the
 * group order, then the hash is truncated as defined in Standards for Efficient
 * Cryptography Group (SECG): SEC1 Elliptic Curve Cryptography, section 4.1.4,
 * step 3.
 */
static int
ecp256_ecdsa_verify(const unsigned char *buf, size_t blen, const TlsEcpPoint *Q,
		    const TlsMpi *r, const TlsMpi *s)
{
	TlsMpi *e, *s_inv, *u1, *u2;
	TlsEcpPoint *R;

	e = ttls_mpi_alloc_stack_init(G_LIMBS);
	s_inv = ttls_mpi_alloc_stack_init(G_LIMBS);
	u1 = ttls_mpi_alloc_stack_init(e->limbs + s_inv->limbs);
	u2 = ttls_mpi_alloc_stack_init(r->limbs + s_inv->limbs);
	R = ttls_mpool_alloc_stack(sizeof(*R));
	ttls_ecp_point_init(R);

	/* Step 1: make sure r and s are in range 1..n-1 */
	if (ttls_mpi_cmp_int(r, 1) < 0 || ttls_mpi_cmp_mpi(r, &G.N) >= 0
	    || ttls_mpi_cmp_int(s, 1) < 0 || ttls_mpi_cmp_mpi(s, &G.N) >= 0)
		return TTLS_ERR_ECP_VERIFY_FAILED;

	/* Step 3: derive MPI from hashed message. */
	derive_mpi(e, buf, blen);

	/* Step 4: u1 = e / s mod n, u2 = r / s mod n */
	ttls_mpi_inv_mod(s_inv, s, &G.N);
	ttls_mpi_mul_mpi(u1, e, s_inv);
	ttls_mpi_mod_mpi(u1, u1, &G.N);
	ttls_mpi_mul_mpi(u2, r, s_inv);
	ttls_mpi_mod_mpi(u2, u2, &G.N);

	/*
	 * Step 5: R = u1 G + u2 Q
	 *
	 * Since we're not using any secret data, no need to pass a RNG to
	 * ttls_ecp_mul() for countermesures.
	 */
	MPI_CHK(ecp256_muladd(R, u1, Q, u2));
	if (ttls_ecp_is_zero(R))
		return TTLS_ERR_ECP_VERIFY_FAILED;

	/*
	 * Step 6: convert xR to an integer (no-op)
	 * Step 7: reduce xR mod n (gives v)
	 */
	ttls_mpi_mod_mpi(&R->X, &R->X, &G.N);

	/* Step 8: check if v (that is, R.X) is equal to r. */
	return ttls_mpi_cmp_mpi(&R->X, r);
}

const TlsEcpGrp SECP256_G ____cacheline_aligned = {
	.id		= TTLS_ECP_DP_SECP256R1,
	.bits		= G_BITS,

	.mul		= ecp256_mul_comb,
	.muladd		= ecp256_muladd,
	.gen_keypair	= ecp256_gen_keypair,
	.ecdsa_sign	= ecp256_ecdsa_sign,
	.ecdsa_verify	= ecp256_ecdsa_verify,
};
