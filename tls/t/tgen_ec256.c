/**
 *		Tempesta TLS
 *
 * Precomputation of the static table for m * G in NIST secp256r1.
 *
 * Copyright (C) 2020 Tempesta Technologies, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include "ttls_mocks.h"
#include "../bignum.c"
#include "../ciphersuites.c"
#include "../dhm.c" /* mpool.c requires DHM routines. */
#include "../asn1.c"
#include "../ec_p256.c"
#include "../ecp.c"
#include "../mpool.c"

/* Mock irrelevant groups. */
const TlsEcpGrp SECP384_G = {};
const TlsEcpGrp CURVE25519_G = {};

static void
print_T(TmpEcpPoint *T, int tid)
{
	int i;

	printf("\t{ /*    Table %d    */\n", tid);
	for (i = 0; i < G_W_SZ; ++i) {
		unsigned long *x = MPI_P(&T[i].p.X);
		unsigned long *y = MPI_P(&T[i].p.Y);

		printf("\t {{%#16lxUL, %#16lxUL,\n", x[0], x[1]);
		printf("\t   %#16lxUL, %#16lxUL},\n", x[2], x[3]);
		printf("\t  {%#16lxUL, %#16lxUL,\n", y[0], y[1]);
		printf("\t   %#16lxUL, %#16lxUL}}%s\n", y[2], y[3],
			i < G_W_SZ - 1 ? "," : "");
	}
	printf("\t}%s\n", tid == G_D ? "" : ",");
}

/*
 * Prepare precomputed points to use them in ecp_mul_comb().
 *
 * Wse fixed-base comb method with V=D tables, GECC 3.45 & 3.47.
 *
 * If i = i_{w-1} ... i_1 is the binary representation of i, then
 * T[i] = i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + P
 */
static void
generate_T0(TmpEcpPoint T[G_W_SZ])
{
	int i, j, k;
	TlsEcpPoint *cur, *TT[G_W_SZ];

	/*
	 * Set T[0] = P and T[2^{i-1}] = 2^{di} P for i = 1 .. w-1
	 * (this is not the final value).
	 */
	ttls_ecp_copy(&T[0].p, &G.G);

	for (k = 0, i = 1; i < G_W_SZ; i <<= 1) {
		cur = &T[i].p;
		ttls_ecp_copy(cur, &T[i >> 1].p);
		for (j = 0; j < G_D; j++)
			ecp256_double_jac(cur, cur);

		TT[k++] = cur;
	}
	ecp256_normalize_jac_many(TT, k);

	/*
	 * Compute the remaining ones using the minimal number of additions
	 * Be careful to update T[2^l] only after using it!
	 */
	for (k = 0, i = 1; i < G_W_SZ; i <<= 1) {
		j = i;
		while (j--) {
			ecp256_add_mixed(&T[i + j].p, &T[j].p, &T[i].p);
			TT[k++] = &T[i + j].p;
		}
	}
	ecp256_normalize_jac_many(TT, k);
}

/**
 * Generate i'th table for multi-table fixed-base comb (GECC 3.45, 3.47):
 *
 *	T_{i}[j] = 2 * T_{i-1}[j]
 */
static void
generate_Ti(TmpEcpPoint T[G_W_SZ])
{
	int i;
	TlsEcpPoint *TT[G_W_SZ];

	for (i = 0; i < G_W_SZ; ++i) {
		ecp256_double_jac(&T[i].p, &T[i].p);
		TT[i] = &T[i].p;
	}
	ecp256_normalize_jac_many(TT, G_W_SZ);
}

int
main(int argc, char *argv[])
{
	int i;
	static TmpEcpPoint T[G_W_SZ];

	ttls_mpool_init();

	/* Initialize auxiliary EC points. */
	for (i = 0; i < G_W_SZ; ++i) {
		T[i].p.X.limbs = G_LIMBS * 2;
		T[i].p.X._off = (long)T[i].x - (long)&T[i].p.X;
		T[i].p.Y.limbs = G_LIMBS * 2;
		T[i].p.Y._off = (long)T[i].y - (long)&T[i].p.Y;
		T[i].p.Z.limbs = G_LIMBS;
		T[i].p.Z._off = (long)T[i].z - (long)&T[i].p.Z;
	}

	printf("\t/*\n"
	       "\t * Generated by t/tgen_ec256.c for G_W_SZ=%u G_D=%u,"
	       " total size = %lu.\n"
	       "\t */\n", G_W_SZ, G_D, G_W_SZ * (G_D + 1) * sizeof(EcpXY));

	generate_T0(T);
	print_T(T, 0);

	for (i = 1; i <= G_D; ++i) {
		generate_Ti(T);
		print_T(T, i);
	}

	ttls_mpool_exit();

	return 0;
}
