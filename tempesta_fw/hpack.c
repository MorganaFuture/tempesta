/**
 *		Tempesta FW
 *
 * Copyright (C) 2019 Tempesta Technologies, Inc.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59
 * Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#if DBG_HPACK == 0
#undef DEBUG
#endif

#include "lib/str.h"
#include "pool.h"
#include "str.h"
#include "http_msg.h"
#include "hpack.h"

/**
 * Huffman decoder state machine:
 * |shift| = modulus of the "shift" field always contains
 *	     number of bits in the Huffman-encoded representation,
 *	     which must be taken by decoder on this step.
 * NB! for short tables (f.e. 8-entries tables) difference
 *     in the prefix length (f.e. 7 bits for the big tables
 *     minus 3 bits for short tables = 4 bits) was pre-added
 *     to the value of "shift" field (just to speedup the decoder),
 *     thus true value of the Huffman-encoded prefix, which must
 *     be taken by decoder on this step is equal to the "shift"
 *     minus three.
 * shift > 0 ---> normal symbol:
 *    offset = signed char representation of the decoded symbol.
 * shift < 0 && offset == 0 ---> EOS.
 *    |shift| = number of bits in the truncated path.
 * shift < 0 && offset > 0 ---> jump to next table:
 *    offset = offset of the next table.
 */
typedef struct {
	short	shift;
	short	offset;
} HTState;

#define HT_NBITS			7
#define HT_MBITS			3
#define HT_NMASK			127
#define HT_MMASK			7
#define HT_SMALL			640
#define HT_EOS_HIGH			0xFF

/* TODO #309: @ht_decode table should be generated on compile stage .*/
static const HTState ht_decode[] ____cacheline_aligned = {
/* --- [TABLE-128: offset = 0] --- */
	{5, 48},		/* 5: '0' (48) */
	{5, 48},		/* 5: '0' (48) */
	{5, 48},		/* 5: '0' (48) */
	{5, 48},		/* 5: '0' (48) */
	{5, 49},		/* 5: '1' (49) */
	{5, 49},		/* 5: '1' (49) */
	{5, 49},		/* 5: '1' (49) */
	{5, 49},		/* 5: '1' (49) */
	{5, 50},		/* 5: '2' (50) */
	{5, 50},		/* 5: '2' (50) */
	{5, 50},		/* 5: '2' (50) */
	{5, 50},		/* 5: '2' (50) */
	{5, 97},		/* 5: 'a' (97) */
	{5, 97},		/* 5: 'a' (97) */
	{5, 97},		/* 5: 'a' (97) */
	{5, 97},		/* 5: 'a' (97) */
	{5, 99},		/* 5: 'c' (99) */
	{5, 99},		/* 5: 'c' (99) */
	{5, 99},		/* 5: 'c' (99) */
	{5, 99},		/* 5: 'c' (99) */
	{5, 101},		/* 5: 'e' (101) */
	{5, 101},		/* 5: 'e' (101) */
	{5, 101},		/* 5: 'e' (101) */
	{5, 101},		/* 5: 'e' (101) */
	{5, 105},		/* 5: 'i' (105) */
	{5, 105},		/* 5: 'i' (105) */
	{5, 105},		/* 5: 'i' (105) */
	{5, 105},		/* 5: 'i' (105) */
	{5, 111},		/* 5: 'o' (111) */
	{5, 111},		/* 5: 'o' (111) */
	{5, 111},		/* 5: 'o' (111) */
	{5, 111},		/* 5: 'o' (111) */
	{5, 115},		/* 5: 's' (115) */
	{5, 115},		/* 5: 's' (115) */
	{5, 115},		/* 5: 's' (115) */
	{5, 115},		/* 5: 's' (115) */
	{5, 116},		/* 5: 't' (116) */
	{5, 116},		/* 5: 't' (116) */
	{5, 116},		/* 5: 't' (116) */
	{5, 116},		/* 5: 't' (116) */
	{6, 32},		/* 6: ' ' (32) */
	{6, 32},		/* 6: ' ' (32) */
	{6, 37},		/* 6: '%' (37) */
	{6, 37},		/* 6: '%' (37) */
	{6, 45},		/* 6: '-' (45) */
	{6, 45},		/* 6: '-' (45) */
	{6, 46},		/* 6: '.' (46) */
	{6, 46},		/* 6: '.' (46) */
	{6, 47},		/* 6: '/' (47) */
	{6, 47},		/* 6: '/' (47) */
	{6, 51},		/* 6: '3' (51) */
	{6, 51},		/* 6: '3' (51) */
	{6, 52},		/* 6: '4' (52) */
	{6, 52},		/* 6: '4' (52) */
	{6, 53},		/* 6: '5' (53) */
	{6, 53},		/* 6: '5' (53) */
	{6, 54},		/* 6: '6' (54) */
	{6, 54},		/* 6: '6' (54) */
	{6, 55},		/* 6: '7' (55) */
	{6, 55},		/* 6: '7' (55) */
	{6, 56},		/* 6: '8' (56) */
	{6, 56},		/* 6: '8' (56) */
	{6, 57},		/* 6: '9' (57) */
	{6, 57},		/* 6: '9' (57) */
	{6, 61},		/* 6: '=' (61) */
	{6, 61},		/* 6: '=' (61) */
	{6, 65},		/* 6: 'A' (65) */
	{6, 65},		/* 6: 'A' (65) */
	{6, 95},		/* 6: '_' (95) */
	{6, 95},		/* 6: '_' (95) */
	{6, 98},		/* 6: 'b' (98) */
	{6, 98},		/* 6: 'b' (98) */
	{6, 100},		/* 6: 'd' (100) */
	{6, 100},		/* 6: 'd' (100) */
	{6, 102},		/* 6: 'f' (102) */
	{6, 102},		/* 6: 'f' (102) */
	{6, 103},		/* 6: 'g' (103) */
	{6, 103},		/* 6: 'g' (103) */
	{6, 104},		/* 6: 'h' (104) */
	{6, 104},		/* 6: 'h' (104) */
	{6, 108},		/* 6: 'l' (108) */
	{6, 108},		/* 6: 'l' (108) */
	{6, 109},		/* 6: 'm' (109) */
	{6, 109},		/* 6: 'm' (109) */
	{6, 110},		/* 6: 'n' (110) */
	{6, 110},		/* 6: 'n' (110) */
	{6, 112},		/* 6: 'p' (112) */
	{6, 112},		/* 6: 'p' (112) */
	{6, 114},		/* 6: 'r' (114) */
	{6, 114},		/* 6: 'r' (114) */
	{6, 117},		/* 6: 'u' (117) */
	{6, 117},		/* 6: 'u' (117) */
	{7, 58},		/* 7: ':' (58) */
	{7, 66},		/* 7: 'B' (66) */
	{7, 67},		/* 7: 'C' (67) */
	{7, 68},		/* 7: 'D' (68) */
	{7, 69},		/* 7: 'E' (69) */
	{7, 70},		/* 7: 'F' (70) */
	{7, 71},		/* 7: 'G' (71) */
	{7, 72},		/* 7: 'H' (72) */
	{7, 73},		/* 7: 'I' (73) */
	{7, 74},		/* 7: 'J' (74) */
	{7, 75},		/* 7: 'K' (75) */
	{7, 76},		/* 7: 'L' (76) */
	{7, 77},		/* 7: 'M' (77) */
	{7, 78},		/* 7: 'N' (78) */
	{7, 79},		/* 7: 'O' (79) */
	{7, 80},		/* 7: 'P' (80) */
	{7, 81},		/* 7: 'Q' (81) */
	{7, 82},		/* 7: 'R' (82) */
	{7, 83},		/* 7: 'S' (83) */
	{7, 84},		/* 7: 'T' (84) */
	{7, 85},		/* 7: 'U' (85) */
	{7, 86},		/* 7: 'V' (86) */
	{7, 87},		/* 7: 'W' (87) */
	{7, 89},		/* 7: 'Y' (89) */
	{7, 106},		/* 7: 'j' (106) */
	{7, 107},		/* 7: 'k' (107) */
	{7, 113},		/* 7: 'q' (113) */
	{7, 118},		/* 7: 'v' (118) */
	{7, 119},		/* 7: 'w' (119) */
	{7, 120},		/* 7: 'x' (120) */
	{7, 121},		/* 7: 'y' (121) */
	{7, 122},		/* 7: 'z' (122) */
	{-7, 640},		/* 7: ---> TABLE 640 */
	{-7, 648},		/* 7: ---> TABLE 648 */
	{-7, 656},		/* 7: ---> TABLE 656 */
	{-7, 128},		/* 7: ---> TABLE 128 */
/* --- [TABLE-128: offset = 128] --- */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 33},		/* 3: '!' (33) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 34},		/* 3: '"' (34) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 40},		/* 3: '(' (40) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 41},		/* 3: ')' (41) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{3, 63},		/* 3: '?' (63) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 39},		/* 4: '\'' (39) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 43},		/* 4: '+' (43) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{4, 124},		/* 4: '|' (124) */
	{5, 35},		/* 5: '#' (35) */
	{5, 35},		/* 5: '#' (35) */
	{5, 35},		/* 5: '#' (35) */
	{5, 35},		/* 5: '#' (35) */
	{5, 62},		/* 5: '>' (62) */
	{5, 62},		/* 5: '>' (62) */
	{5, 62},		/* 5: '>' (62) */
	{5, 62},		/* 5: '>' (62) */
	{6, 0},			/* 6: '\x00' (0) */
	{6, 0},			/* 6: '\x00' (0) */
	{6, 36},		/* 6: '$' (36) */
	{6, 36},		/* 6: '$' (36) */
	{6, 64},		/* 6: '@' (64) */
	{6, 64},		/* 6: '@' (64) */
	{6, 91},		/* 6: '[' (91) */
	{6, 91},		/* 6: '[' (91) */
	{6, 93},		/* 6: ']' (93) */
	{6, 93},		/* 6: ']' (93) */
	{6, 126},		/* 6: '~' (126) */
	{6, 126},		/* 6: '~' (126) */
	{7, 94},		/* 7: '^' (94) */
	{7, 125},		/* 7: '}' (125) */
	{-7, 664},		/* 7: ---> TABLE 664 */
	{-7, 256},		/* 7: ---> TABLE 256 */
/* --- [TABLE-128: offset = 256] --- */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{1, 123},		/* 1: '{' (123) */
	{5, 92},		/* 5: '\\' (92) */
	{5, 92},		/* 5: '\\' (92) */
	{5, 92},		/* 5: '\\' (92) */
	{5, 92},		/* 5: '\\' (92) */
	{5, -61},		/* 5: '\xC3' (195) */
	{5, -61},		/* 5: '\xC3' (195) */
	{5, -61},		/* 5: '\xC3' (195) */
	{5, -61},		/* 5: '\xC3' (195) */
	{5, -48},		/* 5: '\xD0' (208) */
	{5, -48},		/* 5: '\xD0' (208) */
	{5, -48},		/* 5: '\xD0' (208) */
	{5, -48},		/* 5: '\xD0' (208) */
	{6, -128},		/* 6: '\x80' (128) */
	{6, -128},		/* 6: '\x80' (128) */
	{6, -126},		/* 6: '\x82' (130) */
	{6, -126},		/* 6: '\x82' (130) */
	{6, -125},		/* 6: '\x83' (131) */
	{6, -125},		/* 6: '\x83' (131) */
	{6, -94},		/* 6: '\xA2' (162) */
	{6, -94},		/* 6: '\xA2' (162) */
	{6, -72},		/* 6: '\xB8' (184) */
	{6, -72},		/* 6: '\xB8' (184) */
	{6, -62},		/* 6: '\xC2' (194) */
	{6, -62},		/* 6: '\xC2' (194) */
	{6, -32},		/* 6: '\xE0' (224) */
	{6, -32},		/* 6: '\xE0' (224) */
	{6, -30},		/* 6: '\xE2' (226) */
	{6, -30},		/* 6: '\xE2' (226) */
	{7, -103},		/* 7: '\x99' (153) */
	{7, -95},		/* 7: '\xA1' (161) */
	{7, -89},		/* 7: '\xA7' (167) */
	{7, -84},		/* 7: '\xAC' (172) */
	{7, -80},		/* 7: '\xB0' (176) */
	{7, -79},		/* 7: '\xB1' (177) */
	{7, -77},		/* 7: '\xB3' (179) */
	{7, -47},		/* 7: '\xD1' (209) */
	{7, -40},		/* 7: '\xD8' (216) */
	{7, -39},		/* 7: '\xD9' (217) */
	{7, -29},		/* 7: '\xE3' (227) */
	{7, -27},		/* 7: '\xE5' (229) */
	{7, -26},		/* 7: '\xE6' (230) */
	{-7, 672},		/* 7: ---> TABLE 672 */
	{-7, 680},		/* 7: ---> TABLE 680 */
	{-7, 688},		/* 7: ---> TABLE 688 */
	{-7, 696},		/* 7: ---> TABLE 696 */
	{-7, 704},		/* 7: ---> TABLE 704 */
	{-7, 712},		/* 7: ---> TABLE 712 */
	{-7, 720},		/* 7: ---> TABLE 720 */
	{-7, 728},		/* 7: ---> TABLE 728 */
	{-7, 736},		/* 7: ---> TABLE 736 */
	{-7, 744},		/* 7: ---> TABLE 744 */
	{-7, 752},		/* 7: ---> TABLE 752 */
	{-7, 760},		/* 7: ---> TABLE 760 */
	{-7, 768},		/* 7: ---> TABLE 768 */
	{-7, 776},		/* 7: ---> TABLE 776 */
	{-7, 784},		/* 7: ---> TABLE 784 */
	{-7, 792},		/* 7: ---> TABLE 792 */
	{-7, 800},		/* 7: ---> TABLE 800 */
	{-7, 808},		/* 7: ---> TABLE 808 */
	{-7, 816},		/* 7: ---> TABLE 816 */
	{-7, 824},		/* 7: ---> TABLE 824 */
	{-7, 832},		/* 7: ---> TABLE 832 */
	{-7, 384},		/* 7: ---> TABLE 384 */
	{-7, 512},		/* 7: ---> TABLE 512 */
/* --- [TABLE-128: offset = 384] --- */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -85},		/* 3: '\xAB' (171) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -50},		/* 3: '\xCE' (206) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -41},		/* 3: '\xD7' (215) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -31},		/* 3: '\xE1' (225) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -20},		/* 3: '\xEC' (236) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{3, -19},		/* 3: '\xED' (237) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -57},		/* 4: '\xC7' (199) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -49},		/* 4: '\xCF' (207) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -22},		/* 4: '\xEA' (234) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
	{4, -21},		/* 4: '\xEB' (235) */
/* --- [TABLE-128: offset = 512] --- */
	{5, -64},		/* 5: '\xC0' (192) */
	{5, -64},		/* 5: '\xC0' (192) */
	{5, -64},		/* 5: '\xC0' (192) */
	{5, -64},		/* 5: '\xC0' (192) */
	{5, -63},		/* 5: '\xC1' (193) */
	{5, -63},		/* 5: '\xC1' (193) */
	{5, -63},		/* 5: '\xC1' (193) */
	{5, -63},		/* 5: '\xC1' (193) */
	{5, -56},		/* 5: '\xC8' (200) */
	{5, -56},		/* 5: '\xC8' (200) */
	{5, -56},		/* 5: '\xC8' (200) */
	{5, -56},		/* 5: '\xC8' (200) */
	{5, -55},		/* 5: '\xC9' (201) */
	{5, -55},		/* 5: '\xC9' (201) */
	{5, -55},		/* 5: '\xC9' (201) */
	{5, -55},		/* 5: '\xC9' (201) */
	{5, -54},		/* 5: '\xCA' (202) */
	{5, -54},		/* 5: '\xCA' (202) */
	{5, -54},		/* 5: '\xCA' (202) */
	{5, -54},		/* 5: '\xCA' (202) */
	{5, -51},		/* 5: '\xCD' (205) */
	{5, -51},		/* 5: '\xCD' (205) */
	{5, -51},		/* 5: '\xCD' (205) */
	{5, -51},		/* 5: '\xCD' (205) */
	{5, -46},		/* 5: '\xD2' (210) */
	{5, -46},		/* 5: '\xD2' (210) */
	{5, -46},		/* 5: '\xD2' (210) */
	{5, -46},		/* 5: '\xD2' (210) */
	{5, -43},		/* 5: '\xD5' (213) */
	{5, -43},		/* 5: '\xD5' (213) */
	{5, -43},		/* 5: '\xD5' (213) */
	{5, -43},		/* 5: '\xD5' (213) */
	{5, -38},		/* 5: '\xDA' (218) */
	{5, -38},		/* 5: '\xDA' (218) */
	{5, -38},		/* 5: '\xDA' (218) */
	{5, -38},		/* 5: '\xDA' (218) */
	{5, -37},		/* 5: '\xDB' (219) */
	{5, -37},		/* 5: '\xDB' (219) */
	{5, -37},		/* 5: '\xDB' (219) */
	{5, -37},		/* 5: '\xDB' (219) */
	{5, -18},		/* 5: '\xEE' (238) */
	{5, -18},		/* 5: '\xEE' (238) */
	{5, -18},		/* 5: '\xEE' (238) */
	{5, -18},		/* 5: '\xEE' (238) */
	{5, -16},		/* 5: '\xF0' (240) */
	{5, -16},		/* 5: '\xF0' (240) */
	{5, -16},		/* 5: '\xF0' (240) */
	{5, -16},		/* 5: '\xF0' (240) */
	{5, -14},		/* 5: '\xF2' (242) */
	{5, -14},		/* 5: '\xF2' (242) */
	{5, -14},		/* 5: '\xF2' (242) */
	{5, -14},		/* 5: '\xF2' (242) */
	{5, -13},		/* 5: '\xF3' (243) */
	{5, -13},		/* 5: '\xF3' (243) */
	{5, -13},		/* 5: '\xF3' (243) */
	{5, -13},		/* 5: '\xF3' (243) */
	{5, -1},		/* 5: '\xFF' (255) */
	{5, -1},		/* 5: '\xFF' (255) */
	{5, -1},		/* 5: '\xFF' (255) */
	{5, -1},		/* 5: '\xFF' (255) */
	{6, -53},		/* 6: '\xCB' (203) */
	{6, -53},		/* 6: '\xCB' (203) */
	{6, -52},		/* 6: '\xCC' (204) */
	{6, -52},		/* 6: '\xCC' (204) */
	{6, -45},		/* 6: '\xD3' (211) */
	{6, -45},		/* 6: '\xD3' (211) */
	{6, -44},		/* 6: '\xD4' (212) */
	{6, -44},		/* 6: '\xD4' (212) */
	{6, -42},		/* 6: '\xD6' (214) */
	{6, -42},		/* 6: '\xD6' (214) */
	{6, -35},		/* 6: '\xDD' (221) */
	{6, -35},		/* 6: '\xDD' (221) */
	{6, -34},		/* 6: '\xDE' (222) */
	{6, -34},		/* 6: '\xDE' (222) */
	{6, -33},		/* 6: '\xDF' (223) */
	{6, -33},		/* 6: '\xDF' (223) */
	{6, -15},		/* 6: '\xF1' (241) */
	{6, -15},		/* 6: '\xF1' (241) */
	{6, -12},		/* 6: '\xF4' (244) */
	{6, -12},		/* 6: '\xF4' (244) */
	{6, -11},		/* 6: '\xF5' (245) */
	{6, -11},		/* 6: '\xF5' (245) */
	{6, -10},		/* 6: '\xF6' (246) */
	{6, -10},		/* 6: '\xF6' (246) */
	{6, -9},		/* 6: '\xF7' (247) */
	{6, -9},		/* 6: '\xF7' (247) */
	{6, -8},		/* 6: '\xF8' (248) */
	{6, -8},		/* 6: '\xF8' (248) */
	{6, -6},		/* 6: '\xFA' (250) */
	{6, -6},		/* 6: '\xFA' (250) */
	{6, -5},		/* 6: '\xFB' (251) */
	{6, -5},		/* 6: '\xFB' (251) */
	{6, -4},		/* 6: '\xFC' (252) */
	{6, -4},		/* 6: '\xFC' (252) */
	{6, -3},		/* 6: '\xFD' (253) */
	{6, -3},		/* 6: '\xFD' (253) */
	{6, -2},		/* 6: '\xFE' (254) */
	{6, -2},		/* 6: '\xFE' (254) */
	{7, 2},			/* 7: '\x02' (2) */
	{7, 3},			/* 7: '\x03' (3) */
	{7, 4},			/* 7: '\x04' (4) */
	{7, 5},			/* 7: '\x05' (5) */
	{7, 6},			/* 7: '\x06' (6) */
	{7, 7},			/* 7: '\x07' (7) */
	{7, 8},			/* 7: '\x08' (8) */
	{7, 11},		/* 7: '\x0B' (11) */
	{7, 12},		/* 7: '\x0C' (12) */
	{7, 14},		/* 7: '\x0E' (14) */
	{7, 15},		/* 7: '\x0F' (15) */
	{7, 16},		/* 7: '\x10' (16) */
	{7, 17},		/* 7: '\x11' (17) */
	{7, 18},		/* 7: '\x12' (18) */
	{7, 19},		/* 7: '\x13' (19) */
	{7, 20},		/* 7: '\x14' (20) */
	{7, 21},		/* 7: '\x15' (21) */
	{7, 23},		/* 7: '\x17' (23) */
	{7, 24},		/* 7: '\x18' (24) */
	{7, 25},		/* 7: '\x19' (25) */
	{7, 26},		/* 7: '\x1A' (26) */
	{7, 27},		/* 7: '\x1B' (27) */
	{7, 28},		/* 7: '\x1C' (28) */
	{7, 29},		/* 7: '\x1D' (29) */
	{7, 30},		/* 7: '\x1E' (30) */
	{7, 31},		/* 7: '\x1F' (31) */
	{7, 127},		/* 7: '\x7F' (127) */
	{7, -36},		/* 7: '\xDC' (220) */
	{7, -7},		/* 7: '\xF9' (249) */
	{-7, 840},		/* 7: ---> TABLE 840 */
/* --- [TABLE-8: offset = 640] --- */
	{5, 38},		/* 1: '&' (38) */
	{5, 38},		/* 1: '&' (38) */
	{5, 38},		/* 1: '&' (38) */
	{5, 38},		/* 1: '&' (38) */
	{5, 42},		/* 1: '*' (42) */
	{5, 42},		/* 1: '*' (42) */
	{5, 42},		/* 1: '*' (42) */
	{5, 42},		/* 1: '*' (42) */
/* --- [TABLE-8: offset = 648] --- */
	{5, 44},		/* 1: ',' (44) */
	{5, 44},		/* 1: ',' (44) */
	{5, 44},		/* 1: ',' (44) */
	{5, 44},		/* 1: ',' (44) */
	{5, 59},		/* 1: ';' (59) */
	{5, 59},		/* 1: ';' (59) */
	{5, 59},		/* 1: ';' (59) */
	{5, 59},		/* 1: ';' (59) */
/* --- [TABLE-8: offset = 656] --- */
	{5, 88},		/* 1: 'X' (88) */
	{5, 88},		/* 1: 'X' (88) */
	{5, 88},		/* 1: 'X' (88) */
	{5, 88},		/* 1: 'X' (88) */
	{5, 90},		/* 1: 'Z' (90) */
	{5, 90},		/* 1: 'Z' (90) */
	{5, 90},		/* 1: 'Z' (90) */
	{5, 90},		/* 1: 'Z' (90) */
/* --- [TABLE-8: offset = 664] --- */
	{5, 60},		/* 1: '<' (60) */
	{5, 60},		/* 1: '<' (60) */
	{5, 60},		/* 1: '<' (60) */
	{5, 60},		/* 1: '<' (60) */
	{5, 96},		/* 1: '`' (96) */
	{5, 96},		/* 1: '`' (96) */
	{5, 96},		/* 1: '`' (96) */
	{5, 96},		/* 1: '`' (96) */
/* --- [TABLE-8: offset = 672] --- */
	{5, -127},		/* 1: '\x81' (129) */
	{5, -127},		/* 1: '\x81' (129) */
	{5, -127},		/* 1: '\x81' (129) */
	{5, -127},		/* 1: '\x81' (129) */
	{5, -124},		/* 1: '\x84' (132) */
	{5, -124},		/* 1: '\x84' (132) */
	{5, -124},		/* 1: '\x84' (132) */
	{5, -124},		/* 1: '\x84' (132) */
/* --- [TABLE-8: offset = 680] --- */
	{5, -123},		/* 1: '\x85' (133) */
	{5, -123},		/* 1: '\x85' (133) */
	{5, -123},		/* 1: '\x85' (133) */
	{5, -123},		/* 1: '\x85' (133) */
	{5, -122},		/* 1: '\x86' (134) */
	{5, -122},		/* 1: '\x86' (134) */
	{5, -122},		/* 1: '\x86' (134) */
	{5, -122},		/* 1: '\x86' (134) */
/* --- [TABLE-8: offset = 688] --- */
	{5, -120},		/* 1: '\x88' (136) */
	{5, -120},		/* 1: '\x88' (136) */
	{5, -120},		/* 1: '\x88' (136) */
	{5, -120},		/* 1: '\x88' (136) */
	{5, -110},		/* 1: '\x92' (146) */
	{5, -110},		/* 1: '\x92' (146) */
	{5, -110},		/* 1: '\x92' (146) */
	{5, -110},		/* 1: '\x92' (146) */
/* --- [TABLE-8: offset = 696] --- */
	{5, -102},		/* 1: '\x9A' (154) */
	{5, -102},		/* 1: '\x9A' (154) */
	{5, -102},		/* 1: '\x9A' (154) */
	{5, -102},		/* 1: '\x9A' (154) */
	{5, -100},		/* 1: '\x9C' (156) */
	{5, -100},		/* 1: '\x9C' (156) */
	{5, -100},		/* 1: '\x9C' (156) */
	{5, -100},		/* 1: '\x9C' (156) */
/* --- [TABLE-8: offset = 704] --- */
	{5, -96},		/* 1: '\xA0' (160) */
	{5, -96},		/* 1: '\xA0' (160) */
	{5, -96},		/* 1: '\xA0' (160) */
	{5, -96},		/* 1: '\xA0' (160) */
	{5, -93},		/* 1: '\xA3' (163) */
	{5, -93},		/* 1: '\xA3' (163) */
	{5, -93},		/* 1: '\xA3' (163) */
	{5, -93},		/* 1: '\xA3' (163) */
/* --- [TABLE-8: offset = 712] --- */
	{5, -92},		/* 1: '\xA4' (164) */
	{5, -92},		/* 1: '\xA4' (164) */
	{5, -92},		/* 1: '\xA4' (164) */
	{5, -92},		/* 1: '\xA4' (164) */
	{5, -87},		/* 1: '\xA9' (169) */
	{5, -87},		/* 1: '\xA9' (169) */
	{5, -87},		/* 1: '\xA9' (169) */
	{5, -87},		/* 1: '\xA9' (169) */
/* --- [TABLE-8: offset = 720] --- */
	{5, -86},		/* 1: '\xAA' (170) */
	{5, -86},		/* 1: '\xAA' (170) */
	{5, -86},		/* 1: '\xAA' (170) */
	{5, -86},		/* 1: '\xAA' (170) */
	{5, -83},		/* 1: '\xAD' (173) */
	{5, -83},		/* 1: '\xAD' (173) */
	{5, -83},		/* 1: '\xAD' (173) */
	{5, -83},		/* 1: '\xAD' (173) */
/* --- [TABLE-8: offset = 728] --- */
	{5, -78},		/* 1: '\xB2' (178) */
	{5, -78},		/* 1: '\xB2' (178) */
	{5, -78},		/* 1: '\xB2' (178) */
	{5, -78},		/* 1: '\xB2' (178) */
	{5, -75},		/* 1: '\xB5' (181) */
	{5, -75},		/* 1: '\xB5' (181) */
	{5, -75},		/* 1: '\xB5' (181) */
	{5, -75},		/* 1: '\xB5' (181) */
/* --- [TABLE-8: offset = 736] --- */
	{5, -71},		/* 1: '\xB9' (185) */
	{5, -71},		/* 1: '\xB9' (185) */
	{5, -71},		/* 1: '\xB9' (185) */
	{5, -71},		/* 1: '\xB9' (185) */
	{5, -70},		/* 1: '\xBA' (186) */
	{5, -70},		/* 1: '\xBA' (186) */
	{5, -70},		/* 1: '\xBA' (186) */
	{5, -70},		/* 1: '\xBA' (186) */
/* --- [TABLE-8: offset = 744] --- */
	{5, -69},		/* 1: '\xBB' (187) */
	{5, -69},		/* 1: '\xBB' (187) */
	{5, -69},		/* 1: '\xBB' (187) */
	{5, -69},		/* 1: '\xBB' (187) */
	{5, -67},		/* 1: '\xBD' (189) */
	{5, -67},		/* 1: '\xBD' (189) */
	{5, -67},		/* 1: '\xBD' (189) */
	{5, -67},		/* 1: '\xBD' (189) */
/* --- [TABLE-8: offset = 752] --- */
	{5, -66},		/* 1: '\xBE' (190) */
	{5, -66},		/* 1: '\xBE' (190) */
	{5, -66},		/* 1: '\xBE' (190) */
	{5, -66},		/* 1: '\xBE' (190) */
	{5, -60},		/* 1: '\xC4' (196) */
	{5, -60},		/* 1: '\xC4' (196) */
	{5, -60},		/* 1: '\xC4' (196) */
	{5, -60},		/* 1: '\xC4' (196) */
/* --- [TABLE-8: offset = 760] --- */
	{5, -58},		/* 1: '\xC6' (198) */
	{5, -58},		/* 1: '\xC6' (198) */
	{5, -58},		/* 1: '\xC6' (198) */
	{5, -58},		/* 1: '\xC6' (198) */
	{5, -28},		/* 1: '\xE4' (228) */
	{5, -28},		/* 1: '\xE4' (228) */
	{5, -28},		/* 1: '\xE4' (228) */
	{5, -28},		/* 1: '\xE4' (228) */
/* --- [TABLE-8: offset = 768] --- */
	{5, -24},		/* 1: '\xE8' (232) */
	{5, -24},		/* 1: '\xE8' (232) */
	{5, -24},		/* 1: '\xE8' (232) */
	{5, -24},		/* 1: '\xE8' (232) */
	{5, -23},		/* 1: '\xE9' (233) */
	{5, -23},		/* 1: '\xE9' (233) */
	{5, -23},		/* 1: '\xE9' (233) */
	{5, -23},		/* 1: '\xE9' (233) */
/* --- [TABLE-8: offset = 776] --- */
	{6, 1},			/* 2: '\x01' (1) */
	{6, 1},			/* 2: '\x01' (1) */
	{6, -121},		/* 2: '\x87' (135) */
	{6, -121},		/* 2: '\x87' (135) */
	{6, -119},		/* 2: '\x89' (137) */
	{6, -119},		/* 2: '\x89' (137) */
	{6, -118},		/* 2: '\x8A' (138) */
	{6, -118},		/* 2: '\x8A' (138) */
/* --- [TABLE-8: offset = 784] --- */
	{6, -117},		/* 2: '\x8B' (139) */
	{6, -117},		/* 2: '\x8B' (139) */
	{6, -116},		/* 2: '\x8C' (140) */
	{6, -116},		/* 2: '\x8C' (140) */
	{6, -115},		/* 2: '\x8D' (141) */
	{6, -115},		/* 2: '\x8D' (141) */
	{6, -113},		/* 2: '\x8F' (143) */
	{6, -113},		/* 2: '\x8F' (143) */
/* --- [TABLE-8: offset = 792] --- */
	{6, -109},		/* 2: '\x93' (147) */
	{6, -109},		/* 2: '\x93' (147) */
	{6, -107},		/* 2: '\x95' (149) */
	{6, -107},		/* 2: '\x95' (149) */
	{6, -106},		/* 2: '\x96' (150) */
	{6, -106},		/* 2: '\x96' (150) */
	{6, -105},		/* 2: '\x97' (151) */
	{6, -105},		/* 2: '\x97' (151) */
/* --- [TABLE-8: offset = 800] --- */
	{6, -104},		/* 2: '\x98' (152) */
	{6, -104},		/* 2: '\x98' (152) */
	{6, -101},		/* 2: '\x9B' (155) */
	{6, -101},		/* 2: '\x9B' (155) */
	{6, -99},		/* 2: '\x9D' (157) */
	{6, -99},		/* 2: '\x9D' (157) */
	{6, -98},		/* 2: '\x9E' (158) */
	{6, -98},		/* 2: '\x9E' (158) */
/* --- [TABLE-8: offset = 808] --- */
	{6, -91},		/* 2: '\xA5' (165) */
	{6, -91},		/* 2: '\xA5' (165) */
	{6, -90},		/* 2: '\xA6' (166) */
	{6, -90},		/* 2: '\xA6' (166) */
	{6, -88},		/* 2: '\xA8' (168) */
	{6, -88},		/* 2: '\xA8' (168) */
	{6, -82},		/* 2: '\xAE' (174) */
	{6, -82},		/* 2: '\xAE' (174) */
/* --- [TABLE-8: offset = 816] --- */
	{6, -81},		/* 2: '\xAF' (175) */
	{6, -81},		/* 2: '\xAF' (175) */
	{6, -76},		/* 2: '\xB4' (180) */
	{6, -76},		/* 2: '\xB4' (180) */
	{6, -74},		/* 2: '\xB6' (182) */
	{6, -74},		/* 2: '\xB6' (182) */
	{6, -73},		/* 2: '\xB7' (183) */
	{6, -73},		/* 2: '\xB7' (183) */
/* --- [TABLE-8: offset = 824] --- */
	{6, -68},		/* 2: '\xBC' (188) */
	{6, -68},		/* 2: '\xBC' (188) */
	{6, -65},		/* 2: '\xBF' (191) */
	{6, -65},		/* 2: '\xBF' (191) */
	{6, -59},		/* 2: '\xC5' (197) */
	{6, -59},		/* 2: '\xC5' (197) */
	{6, -25},		/* 2: '\xE7' (231) */
	{6, -25},		/* 2: '\xE7' (231) */
/* --- [TABLE-8: offset = 832] --- */
	{6, -17},		/* 2: '\xEF' (239) */
	{6, -17},		/* 2: '\xEF' (239) */
	{7, 9},			/* 3: '\x09' (9) */
	{7, -114},		/* 3: '\x8E' (142) */
	{7, -112},		/* 3: '\x90' (144) */
	{7, -111},		/* 3: '\x91' (145) */
	{7, -108},		/* 3: '\x94' (148) */
	{7, -97},		/* 3: '\x9F' (159) */
/* --- [TABLE-8: offset = 840] --- */
	{6, 10},		/* 2: '\x0A' (10) */
	{6, 10},		/* 2: '\x0A' (10) */
	{6, 13},		/* 2: '\x0D' (13) */
	{6, 13},		/* 2: '\x0D' (13) */
	{6, 22},		/* 2: '\x16' (22) */
	{6, 22},		/* 2: '\x16' (22) */
	{6, 0},			/* 2: EOS */
	{6, 0},			/* 2: EOS */
};

#define HP_STR(str)						\
	(&(TfwHPackStr){					\
		.ptr = str,					\
		.len = sizeof(str) - 1,				\
		.count = -1					\
	})

static const TfwHPackEntry static_table[] ____cacheline_aligned = {
	{ HP_STR(":authority"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR(":method"),		HP_STR("GET"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":method"),		HP_STR("POST"), TFW_HTTP_HDR_RAW },
	{ HP_STR(":path"),		HP_STR("/"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":path"),	HP_STR("/index.html"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":scheme"),		HP_STR("http"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":scheme"),		HP_STR("https"), TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("200"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("204"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("206"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("304"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("400"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("404"),	TFW_HTTP_HDR_RAW },
	{ HP_STR(":status"),		HP_STR("500"),	TFW_HTTP_HDR_RAW },
	{ HP_STR("accept-charset"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("accept-encoding"), HP_STR("gzip, deflate"), TFW_HTTP_HDR_RAW },
	{ HP_STR("accept-language"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("accept-ranges"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("accept"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("access-control-allow-origin"), NULL,	TFW_HTTP_HDR_RAW },
	{ HP_STR("age"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("allow"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("authorization"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("cache-control"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("content-disposition"), NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("content-encoding"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("content-language"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("content-length"),	NULL,	TFW_HTTP_HDR_CONTENT_LENGTH },
	{ HP_STR("content-location"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("content-range"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("content-type"),	NULL,	TFW_HTTP_HDR_CONTENT_TYPE },
	{ HP_STR("cookie"),		NULL,		TFW_HTTP_HDR_COOKIE },
	{ HP_STR("date"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("etag"),		NULL,		TFW_HTTP_HDR_ETAG },
	{ HP_STR("expect"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("expires"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("from"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("host"),		NULL,		TFW_HTTP_HDR_HOST },
	{ HP_STR("if-match"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("if-modified-since"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("if-none-match"),	NULL,	TFW_HTTP_HDR_IF_NONE_MATCH },
	{ HP_STR("if-range"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("if-unmodified-since"), NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("last-modified"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("link"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("location"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("max-forwards"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("proxy-authenticate"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("proxy-authorization"), NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("range"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("referer"),		NULL,		TFW_HTTP_HDR_REFERER },
	{ HP_STR("refresh"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("retry-after"),	NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("server"),		NULL,		TFW_HTTP_HDR_SERVER },
	{ HP_STR("set-cookie"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("strict-transport-security"), NULL,	TFW_HTTP_HDR_RAW },
	{ HP_STR("transfer-encoding"),	NULL,	TFW_HTTP_HDR_TRANSFER_ENCODING },
	{ HP_STR("user-agent"),		NULL,	TFW_HTTP_HDR_USER_AGENT },
	{ HP_STR("vary"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("via"),		NULL,		TFW_HTTP_HDR_RAW },
	{ HP_STR("www-authenticate"),	NULL,		TFW_HTTP_HDR_RAW }
};

#define HPACK_STATIC_ENTRIES (sizeof(static_table) / sizeof(TfwHPackEntry))

/* Limit for the HPACK variable-length integer. */
#define HPACK_LIMIT			(1 << 20)

/*
 * Estimated overhead associated with an encoder/decoder index entry (see
 * RFC 7541 section 4.1 for details).
 */
#define HPACK_ENTRY_OVERHEAD		32

/*
 * ------------------------------------------------------------------------
 *	HPACK Decoder functionality
 * ------------------------------------------------------------------------
 */

/* States HPACK decoder message processing. */
enum {
	HPACK_STATE_READY		= 0,
	HPACK_STATE_INDEX,
	HPACK_STATE_NAME,
	HPACK_STATE_NAME_LENGTH,
	HPACK_STATE_NAME_TEXT,
	HPACK_STATE_INDEXED_NAME_TEXT,
	HPACK_STATE_VALUE,
	HPACK_STATE_VALUE_LENGTH,
	HPACK_STATE_VALUE_TEXT,
	HPACK_STATE_ALL_INDEXED,
	HPACK_STATE_WINDOW,
	_HPACK_STATE_NUM
};

#define HPACK_STATE_MASK		0x0F

/* Index should be added into decoder dynamic table. */
#define HPACK_FLAGS_ADD			0x010
/* Index without literal value. */
#define HPACK_FLAGS_NO_VALUE		0x020
/* Transit header field. */
#define HPACK_FLAGS_TRANSIT		0x040
/* Huffman encoding used for field name. */
#define HPACK_FLAGS_HUFFMAN_NAME	0x080
/* Huffman encoding used for field value. */
#define HPACK_FLAGS_HUFFMAN_VALUE	0x100

#define NEXT_STATE(new)						\
do {								\
	state &= ~HPACK_STATE_MASK;				\
	state |= (new);						\
} while (0)

/*
 * Flexible integer decoding as specified in the HPACK RFC-7541. If the
 * variable-length integer greater than defined limit, this is the malformed
 * request and we should drop the parsing process.
 */
#define GET_FLEXIBLE(x, new_state)				\
do {								\
	unsigned int __m = 0;					\
	unsigned int __c;					\
	do {							\
		if (src >= last) {				\
			hp->shift = __m;			\
			NEXT_STATE(new_state);			\
			goto out;				\
		}						\
		__c = *src++;					\
		x += (__c & 127) << __m;			\
		__m += 7;					\
		if ((x) > HPACK_LIMIT) {			\
			r = T_DROP;				\
			goto out;				\
		}						\
	} while (__c > 127);					\
} while (0)

/* Continue decoding after interruption due to absence of the next fragment.
 * If the variable-length integer greater than defined limit, this is the
 * malformed request and we should drop the parsing process.
 */
#define GET_CONTINUE(x)						\
do {								\
	unsigned int __m = hp->shift;				\
	unsigned int __c = *src++;				\
	WARN_ON_ONCE(!x);					\
	x += (__c & 127) << __m;				\
	__m += 7;						\
	if ((x) > HPACK_LIMIT) {				\
		r = T_DROP;					\
		goto out;					\
	}							\
	while (__c > 127) {					\
		if (src >= last) {				\
			hp->shift = __m;			\
			goto out;				\
		}						\
		__c = *src++;					\
		x = (__c & 127) << __m | x;			\
		__m += 7;					\
		if ((x) > HPACK_LIMIT) {			\
			r = T_DROP;				\
			goto out;				\
		}						\
	}							\
} while (0)

#define SET_NEXT()						\
do {								\
	hp->curr += 8;						\
	hp->hctx = hp->hctx << 8 | *src++;			\
	--hp->length;						\
	T_DBG3("%s: set next, hp->curr=%d, hp->hctx=%hx,"	\
	       " hp->length=%lu, n=%lu, to_parse=%lu\n",	\
	       __func__, hp->curr, hp->hctx, hp->length, n,	\
	       last - src);					\
} while (0)

#define	BUFFER_NAME_OPEN(length)				\
do {								\
	WARN_ON_ONCE(!TFW_STR_EMPTY(it->hdr));			\
	BUFFER_GET(length, it);					\
	if (!it->pos) {						\
		r = T_DROP;					\
		goto out;					\
	}							\
	if (!it->start_pos)					\
		it->start_pos = it->pos;			\
	it->hdr->data = it->pos;				\
	it->hdr->len = length;					\
	it->next = it->hdr;					\
} while (0)

#define	BUFFER_NEXT(len)					\
({								\
	TfwStr *new = NULL;					\
	TfwPool *rpool = req->pool;				\
	BUFFER_GET(len, it);					\
	if (it->pos) {						\
		new = tfw_hpack_exp_hdr(rpool, len, it);	\
		it->next = new;					\
	}							\
	new;							\
})

#define	BUFFER_VAL_OPEN(length)					\
do {								\
	WARN_ON_ONCE(TFW_STR_EMPTY(it->hdr));			\
	it->nm_len = it->hdr->len - 1;				\
	if (!BUFFER_NEXT(length)) {				\
		r = T_DROP;					\
		goto out;					\
	}							\
} while (0)

#define	BUFFER_WRITE(data, len, it)				\
do {								\
	BUG_ON(!(len));						\
	WARN_ON_ONCE((len) > (it)->rspace);			\
	memcpy_fast((it)->pos, data, len);			\
	(it)->rspace -= len;					\
	(it)->pos += len;					\
} while (0)

#define	BUFFER_WRITE_COLON()					\
do {								\
	WARN_ON_ONCE(it->rspace);				\
	it->pos = tfw_pool_alloc_not_align(it->pool, 1);	\
	T_DBG3("%s: write colon, it->pos=[%p], it->pos=%lu\n",	\
	       __func__, it->pos, (unsigned long)it->pos);	\
	if (!it->pos) {						\
		r = T_DROP;					\
		goto out;					\
	}							\
	if (!tfw_hpack_exp_hdr(req->pool, 1, it)) {		\
		r = T_DROP;					\
		goto out;					\
	}							\
	memcpy_fast(it->pos, ":", 1);				\
} while (0)

#define	BUFFER_WRITE_CRLF()					\
do {								\
	WARN_ON_ONCE(it->rspace);				\
	it->pos = tfw_pool_alloc_not_align(it->pool, 2);	\
	T_DBG3("%s: write crlf, it->pos=[%p], it->pos=%lu\n",	\
	       __func__, it->pos, (unsigned long)it->pos);	\
	if (!it->pos) {						\
		r = T_DROP;					\
		goto out;					\
	}							\
	memcpy_fast(it->pos, "\r\n", 2);			\
} while (0)

#define	HPACK_DECODE_STRING(len)				\
do {								\
	T_DBG3("%s: decoding, len=%lu, n=%lu, to_parse=%lu\n",	\
	       __func__, len, n, last - src);			\
	r = tfw_huffman_decode(hp, req, src, len);		\
	src += len;						\
	if (r)							\
		goto out;					\
	T_DBG3("%s: decoded, to_parse=%lu\n", __func__,		\
	       last - src);					\
	WARN_ON_ONCE(hp->length);				\
	hp->hctx = 0;						\
	tfw_huffman_init(hp);					\
} while (0)

#define HPACK_COPY_STRING(len)					\
do {								\
	BUFFER_WRITE(src, len, it);				\
	hp->length -= len;					\
	src += len;						\
	T_DBG3("%s: copy plain, len=%lu, n=%lu, to_parse=%lu,"	\
	       " hp->length=%lu\n", __func__, len, n,		\
	       last - src, hp->length);				\
	if (hp->length)						\
		goto  out;					\
} while (0)

#define STATIC_INDEXED(ent)			((ent)->tag >= 0)

static unsigned long act_hp_str_n;

static inline TfwStr *
tfw_hpack_exp_hdr(TfwPool *__restrict pool, unsigned long len,
		  TfwMsgParseIter *__restrict it)
{
	TfwStr *new;
	TfwStr *hdr = it->hdr;

	if (!(new = tfw_str_add_compound(pool, hdr)))
		return NULL;

	new->data = it->pos;
	new->len = len;
	hdr->len += len;

	return new;
}

static inline int
tfw_hpack_huffman_write(char sym, TfwHttpReq *__restrict req)
{
	bool np;
	TfwMsgParseIter *it = &req->pit;

	if (it->rspace) {
		--it->rspace;
		*it->pos++ = sym;
		return 0;
	}

	if (!(it->pos = __tfw_pool_alloc(it->pool, 1, false, &np)))
		return -ENOMEM;

	*it->pos = sym;

	T_DBG3("%s: it->rspace=%lu, sym=%c, np=%d\n", __func__,
	       it->rspace, sym, np);

	if (!np) {
		TfwStr *hdr = it->hdr;
		TfwStr *last = TFW_STR_LAST(hdr);

		T_DBG3("%s: add to hdr, hdr->len=%lu, last->len=%lu,"
		       " last->data=%.*s\n", __func__, hdr->len, last->len,
		       (int)last->len, last->data);

		++hdr->len;
		if (!TFW_STR_PLAIN(hdr))
			++last->len;
		return 0;
	}

	return tfw_hpack_exp_hdr(req->pool, 1, it) ? 0 : -ENOMEM;
}

static int
huffman_decode_tail(TfwHPack *__restrict hp, TfwHttpReq *__restrict req,
		    unsigned int offset)
{
	char sym;
	unsigned int i;

	for (;;) {
		int shift;

		if (hp->curr == -HT_NBITS) {
			if (likely(offset == 0))
				return T_OK;
			else
				return T_DROP;
		}

		i = (hp->hctx << -hp->curr) & HT_NMASK;
		shift = ht_decode[offset + i].shift;
		T_DBG3("%s: hp->curr=%d, hp->hctx=%hx, hp->length=%lu,"
		       " i=%u, shift=%d, offset=%u\n", __func__,
		       hp->curr, hp->hctx, hp->length, i, shift, offset);
		if (likely(shift >= 0)) {
			if (shift <= hp->curr + HT_NBITS) {
				sym = (char)ht_decode[offset + i].offset;
				if (tfw_hpack_huffman_write(sym, req))
					return T_DROP;

				hp->curr -= shift;
				offset = 0;
			} else {
				break;
			}
		} else {
			/*
			 * Last full prefix processed here, to allow EOS
			 * padding detection.
			 */
			if (likely(offset == 0)) {
				if ((i ^ (HT_EOS_HIGH >> 1)) <
				    (1U << -hp->curr)) {
					return T_OK;
				}
			}
			/*
			 * The first condition here equivalent to the
			 * '-shift <= hp->curr + HT_NBITS', but working
			 * faster.
			 */
			if (shift >= -HT_NBITS - hp->curr
			    && ht_decode[offset + i].offset == 0)
			{
				T_DBG3("%s: unexpected EOS detected\n",
				       __func__);
				return T_DROP;
			}

			return T_DROP;
		}
	}
	if (likely(offset == 0)) {
		if ((i ^ (HT_EOS_HIGH >> 1)) < (1U << -hp->curr)) {
			return T_OK;
		}
	}
	return T_DROP;
}

static int
huffman_decode_tail_s(TfwHPack *__restrict hp, TfwHttpReq *__restrict req,
		      unsigned int offset)
{
	char sym;
	int shift;
	unsigned int i;

	if (hp->curr == -HT_MBITS)
		return T_DROP;

	i = (hp->hctx << -hp->curr) & HT_MMASK;
	shift = ht_decode[offset + i].shift;

	T_DBG3("%s: hp->curr=%d, hp->hctx=%hx, hp->length=%lu, i=%u,"
	       " shift=%d, offset=%u\n", __func__, hp->curr, hp->hctx,
	       hp->length, i, shift, offset);

	if (likely(shift >= 0)) {
		if (likely(shift <= hp->curr + HT_NBITS)) {
			sym = (char)ht_decode[offset + i].offset;
			if (tfw_hpack_huffman_write(sym, req))
				return T_DROP;
			hp->curr -= shift;
			return huffman_decode_tail(hp, req, 0);
		}
	} else {
		/*
		 * Condition here equivalent to the
		 * "-shift <= hp->curr + HT_NBITS", but
		 * working faster.
		 */
		if (shift >= -HT_NBITS - hp->curr) {
			if (ht_decode[offset + i].offset == 0) {
				return T_DROP;
			}
		}
	}

	return T_DROP;
}

static int
tfw_huffman_decode(TfwHPack *__restrict hp, TfwHttpReq *__restrict req,
		   const unsigned char *__restrict src, unsigned long n)
{
	unsigned int offset;
	const unsigned char *last = src + n;

	WARN_ON_ONCE(n > hp->length);
	if (unlikely(!n))
		return T_OK;

	SET_NEXT();
	for (;;) {
		offset = 0;
		for (;;) {
			int shift;
			unsigned int i;

			if (hp->curr <= 0) {
				if (likely(src < last)) {
					SET_NEXT();
				} else if (hp->length) {
					return T_POSTPONE;
				} else {
					/*
					 * Last full prefix also processed here
					 * (see hp->curr <= 0 above).
					 */
					return huffman_decode_tail(hp, req,
								   offset);
				}
			}
			i = (hp->hctx >> hp->curr) & HT_NMASK;
			shift = ht_decode[offset + i].shift;
			offset = ht_decode[offset + i].offset;
			T_DBG3("%s: shift, hp->curr=%d, hp->hctx=%hx,"
			       " hp->length=%lu, n=%lu, to_parse=%lu, i=%u,"
			       " shift=%d, offset=%u, offset=%c\n", __func__,
			       hp->curr, hp->hctx, hp->length, n, last - src,
			       i, shift, offset, (char)offset);
			if (shift >= 0) {
				if (tfw_hpack_huffman_write((char)offset, req))
					return T_DROP;
				hp->curr -= shift;
				offset = 0;
			} else {
				hp->curr += shift;
				if (offset >= HT_SMALL) {
					break;
				}
				if (unlikely(offset == 0)) {
					goto end;
				}
			}
		}
		hp->curr += HT_NBITS - HT_MBITS;
		/*
		 * With various optimization options, the anonymous block here
		 * leads to the generation of more efficient code.
		 */
		{
			int shift;
			unsigned int i;

			if (hp->curr < 0) {
				if (likely(src < last)) {
					SET_NEXT();
				} else if (hp->length) {
					return T_POSTPONE;
				} else {
					return huffman_decode_tail_s(hp, req,
								     offset);
				}
			}
			i = (hp->hctx >> hp->curr) & HT_MMASK;
			shift = ht_decode[offset + i].shift;
			offset = ht_decode[offset + i].offset;
			T_DBG3("%s: short shift, hp->curr=%d, hp->hctx=%hx,"
			       " hp->length=%lu, n=%lu, to_parse=%lu, i=%u,"
			       " shift=%d, offset=%u, offset=%c\n", __func__,
			       hp->curr, hp->hctx, hp->length, n, last - src,
			       i, shift, offset, (char)offset);
			if (likely(shift >= 0)) {
				if (tfw_hpack_huffman_write((char)offset, req))
					return T_DROP;
				hp->curr -= shift;
			} else {
				break;
			}
		}
	}
end:
	return T_DROP;
}

static inline TfwHPackStr *
tfw_hpack_create_str(unsigned long len)
{
	TfwHPackStr *str;

	if (!(str = kmalloc(sizeof(TfwHPackStr) + len, GFP_ATOMIC)))
		return NULL;
	str->ptr = (char *)(str + 1);
	str->len = len;
	str->count = 1;

	++act_hp_str_n;

	return str;
}

static inline void
tfw_hpack_str_get(TfwHPackStr *hp_str)
{
	if (hp_str->count == -1)
		return;

	++hp_str->count;
}

static inline void
tfw_hpack_str_put(TfwHPackStr *hp_str)
{
	if (hp_str->count == -1)
		return;

	WARN_ON_ONCE(hp_str->count <= 0);

	if (--hp_str->count == 0) {
		--act_hp_str_n;
		kfree(hp_str);
	}
}

static int
tfw_hpack_create_entry(const TfwHPackEntry *__restrict existent,
		       TfwMsgParseIter *__restrict it,
		       TfwHPackEntry *__restrict entry_out)
{
	char *pos = NULL;
	const TfwStr *c, *end, *hdr = it->hdr;
	unsigned long nm_len = it->nm_len;
	unsigned long val_len = hdr->len - nm_len - 1;

	BUG_ON(TFW_STR_EMPTY(hdr));
	WARN_ON_ONCE(!nm_len || !val_len);

	T_DBG3("%s: nm_len=%lu, val_len=%lu, entry_out->tag=%ld\n", __func__,
	       nm_len, val_len, entry_out->tag);

	if (!existent) {
		if (!(entry_out->name = tfw_hpack_create_str(nm_len)))
			return -ENOMEM;
		entry_out->tag = -1;
		pos = entry_out->name->ptr;
	}
	else {
		tfw_hpack_str_get(existent->name);
		entry_out->name = existent->name;
		entry_out->tag = existent->tag;
	}

	TFW_STR_FOR_EACH_CHUNK(c, hdr, end) {
		if (!existent) {
			memcpy_fast(pos, c->data, c->len);
			T_DBG3("%s: name cycle, nm_len=%lu, len=%lu, pos='%.*s'"
			       "\n", __func__, nm_len, c->len, (int)c->len, pos);
			pos += c->len;
		}
		nm_len -= c->len;
		if (unlikely(!nm_len))
			break;
	}

	++c;
	WARN_ON_ONCE(c >= end || *c->data != ':');

	if (!(entry_out->value = tfw_hpack_create_str(val_len))) {
		tfw_hpack_str_put(entry_out->name);
		return -ENOMEM;
	}

	pos = entry_out->value->ptr;
	while (++c < end) {
		memcpy_fast(pos, c->data, c->len);
		T_DBG3("%s: value cycle, val_len=%lu, len=%lu, pos='%.*s'"
		       "\n", __func__, val_len, c->len, (int)c->len, pos);
		pos += c->len;
		val_len -= c->len;
	}
	WARN_ON_ONCE(val_len);

	return 0;
}

static inline void
tfw_hpack_free_entry(TfwHPackEntry *entry)
{
	tfw_hpack_str_put(entry->name);
	tfw_hpack_str_put(entry->value);
}

static int
tfw_hpack_add_index(TfwHPackDTbl *__restrict tbl,
		    const TfwHPackEntry *__restrict existent,
		    TfwMsgParseIter *__restrict it)
{
	unsigned int delta;
	unsigned long name_len;
	TfwHPackEntry entry;
	const TfwHPackStr *name, *value;
	unsigned int window, size, new_size;
	unsigned int count = tbl->n;
	unsigned int curr = tbl->curr;
	unsigned int length = tbl->length;
	TfwHPackEntry *entries = tbl->entries;
	int r = 0;

	if ((r = tfw_hpack_create_entry(existent, it, &entry)))
		return r;

	name = entry.name;
	value = entry.value;
	name_len = name->len;

	/* Check for integer overflow occurred during @delta calculation. */
	if ((delta = HPACK_ENTRY_OVERHEAD + name_len) < name_len
	    || (delta += value->len) < value->len)
	{
		T_WARN("HPACK decoder: very big header (name->len = %lu,"
		       " valueb->len = %lu)."
		       " The entry cannot be added into dynamic table\n",
		       name_len, value->len);
		r = -EINVAL;
		goto out;
	}

	size = tbl->size;
	new_size = size + delta;
	window = tbl->window;

	T_DBG3("%s: max table size: %u, current size: %u, new size: %u, delta:"
	       " %u\n", __func__, window, size, new_size, delta);
	/*
	 * The last condition 'new_size < delta' was added to handle an
	 * integer overflow, which can occur during summation of the actual
	 * window size with delta.
	 */
	if (new_size > window || unlikely(new_size < delta)) {
		if (delta <= window) {
			TfwHPackEntry *cp;
			unsigned int early = curr;

			if (curr >= count) {
				early -= count;
			} else {
				early += length - count;
			}

			window -= delta;
			T_DBG3("%s: curr: %u, early entry: %u (%u entries),"
			       "maximum allowed decreased size: %u\n",  __func__,
			       curr, early, count, window);

			cp = entries + early;
			do {
				TfwHPackStr *np = cp->name;
				TfwHPackStr *vp = cp->value;

				size -= HPACK_ENTRY_OVERHEAD + np->len + vp->len;
				T_DBG3("%s: dropped index: %u\n", __func__,
				       early);
				tfw_hpack_free_entry(cp);
				early++;
				cp++;
				count--;
				if (unlikely(early == length)) {
					early = 0;
					cp = entries;
				}
			} while (size > window);

			new_size = size + delta;
		} else {
			/*
			 * This branch handles rare case where delta itself is
			 * greater than the current window size. Clean of the
			 * entire table and exit in this case.
			 */
			T_DBG3("%s: cleaning of the entire table...",  __func__);
			if (count) {
				TfwHPackEntry *cp;

				if (curr >= count) {
					curr -= count;
				} else {
					curr += length - count;
				}

				cp = entries + curr;
				do {
					T_DBG3("%s: drop index: %u\n", __func__,
					       curr);
					tfw_hpack_free_entry(cp);
					curr++;
					cp++;
					if (unlikely(curr == length)) {
						curr = 0;
						cp = entries;
					}
				} while (--count);
				tbl->n = 0;
				tbl->curr = 0;
				tbl->size = 0;
			}
			goto out;
		}
	} else if (unlikely(count == length)) {
		TfwHPackEntry *previous = entries;
		TfwPool *pool = tbl->pool;
		unsigned long block, wrap;

		T_DBG3("%s: reallocation index structures...", __func__);
		if (length) {
			block = length * sizeof(TfwHPackEntry);
			entries = tfw_pool_realloc_no_copy(pool, entries,
							   block, block << 1);
			if (unlikely(!entries)) {
				r = -ENOMEM;
				goto out;
			}

			length <<= 1;
			wrap = curr * sizeof(TfwHPackEntry);
			block -= wrap;
			if (!curr && entries == previous) {
				curr = count;
			}
			else if (entries == previous) {
				memcpy_fast(entries + wrap + block,
					    previous + wrap, block);
			}
			else {
				if (block)
					memcpy_fast(entries, previous + wrap,
						    block);
				if (wrap)
					memcpy_fast(entries + block, previous,
						    wrap);

				tfw_pool_clean(pool);
				curr = count;
			}
		} else {
			length = 32;
			block = length * sizeof(TfwHPackEntry);
			entries = tfw_pool_alloc(pool, block);
			if (unlikely(!entries)) {
				r = -ENOMEM;
				goto out;
			}
		}
		T_DBG3("%s: table extended, length=%u, curr=%u\n", __func__,
		       length, curr);

		tbl->length = length;
		tbl->entries = entries;
	}

	entries += curr;
	*entries = entry;

	curr++;
	if (unlikely(curr == length))
		curr = 0;
	tbl->curr = curr;
	tbl->n = count + 1;
	tbl->size = new_size;

	T_DBG3("%s: item added, tbl->curr=%u, tbl->n=%u, tbl->length=%u\n",
	       __func__, tbl->curr, tbl->n, tbl->length);

	return 0;
out:
	T_DBG3("%s: item not added (r=%d)\n", __func__, r);
	tfw_hpack_free_entry(&entry);

	return r;
}

static const TfwHPackEntry *
tfw_hpack_find_index(TfwHPackDTbl *__restrict tbl, unsigned long index)
{
	const TfwHPackEntry *entry = NULL;

	if (index <= HPACK_STATIC_ENTRIES) {
		entry = static_table + index - 1;
		BUG_ON(!entry->name);
		return entry;
	}

	WARN_ON_ONCE(tbl->n > tbl->length);
	index -= HPACK_STATIC_ENTRIES;
	if (index <= tbl->n) {
		unsigned int curr = tbl->curr;

		if (index <= curr) {
			curr -= index;
		} else {
			curr += tbl->length - index;
		}
		T_DBG3("%s: tbl->length=%u, tbl->curr=%u, curr=%u, index=%lu\n",
		      __func__, tbl->length, tbl->curr, curr, index);
		entry = tbl->entries + curr;
		BUG_ON(!entry->name || !entry->value);
		return entry;
	}

	return NULL;
}

static int
tfw_hpack_set_length(TfwHPack *__restrict hp, unsigned long new_size)
{
	TfwHPackDTbl *tbl = &hp->dec_tbl;
	unsigned int size = tbl->size;

	if (new_size > hp->max_window)
		return -EINVAL;

	if (size > new_size) {
		unsigned int count = tbl->n;
		unsigned int early = tbl->curr;
		const unsigned int length = tbl->length;
		TfwHPackEntry *const entries = tbl->entries;
		TfwHPackEntry *cp;

		if (early >= count) {
			early -= count;
		} else {
			early += length - count;
		}
		T_DBG3("%s: tbl->curr=%u, early=%u, count=%u, length=%u,"
		       " new_size=%lu\n", __func__, tbl->curr, early, count,
		       length, new_size);
		cp = entries + early;
		do {
			TfwHPackStr *np = cp->name;
			TfwHPackStr *vp = cp->value;

			WARN_ON_ONCE(!np->len);
			WARN_ON_ONCE(!vp->len);
			size -= HPACK_ENTRY_OVERHEAD + np->len + vp->len;

			T_DBG3("%s: drop index, early=%u, count=%u,"
			       " length=%u\n", __func__, early, count, length);
			tfw_hpack_free_entry(cp);
			early++;
			cp++;
			count--;
			if (unlikely(early == length)) {
				early = 0;
				cp = entries;
			}
		} while (size > new_size);

		tbl->n = count;
		tbl->size = size;
	}

	tbl->window = new_size;

	return 0;
}

static inline void
tfw_huffman_init(TfwHPack *__restrict hp)
{
	hp->curr = -HT_NBITS;
}

int
tfw_hpack_init(TfwHPack *__restrict hp, unsigned int htbl_sz)
{
	bool np;
	TfwHPackETbl *et = &hp->enc_tbl;
	TfwHPackDTbl *dt = &hp->dec_tbl;

	BUILD_BUG_ON(sizeof(TfwHPackNode) > HPACK_ENTRY_OVERHEAD
		     || HPACK_ENC_TABLE_MAX_SIZE > SHRT_MAX);

	tfw_huffman_init(hp);

	dt->window = hp->max_window = htbl_sz;
	if (!(dt->pool = __tfw_pool_new(0)))
		return -ENOMEM;

	et->window = htbl_sz;
	spin_lock_init(&et->lock);
	et->rb_size = HPACK_ENC_TABLE_MAX_SIZE;
	if (!(et->pool = __tfw_pool_new(HPACK_ENC_TABLE_MAX_SIZE))) {
		tfw_pool_destroy(dt->pool);
		return -ENOMEM;
	}
	et->rbuf = __tfw_pool_alloc(et->pool, HPACK_ENC_TABLE_MAX_SIZE,
				    true, &np);
	BUG_ON(np || !et->rbuf);

	return 0;
}

void
tfw_hpack_clean(TfwHPack *__restrict hp)
{
	tfw_pool_destroy(hp->enc_tbl.pool);
	tfw_hpack_set_length(hp, 0);
	tfw_pool_destroy(hp->dec_tbl.pool);
	WARN_ON_ONCE(act_hp_str_n);
}

/*
 * HPACK reinitialization procedure: resetting the non-permanent part
 * of HPACK context and HTTP/2 message iterator before next HPACK
 * processing stage. Note, in result of reinitialization, the @state
 * field of HPACK context will be set to HPACK_STATE_READY (since its
 * value is zero).
 */
static inline void
tfw_hpack_reinit(TfwHPack *__restrict hp, TfwMsgParseIter *__restrict it)
{
	bzero_fast(hp->__off,
		   sizeof(*hp) - offsetof(TfwHPack, __off));
	bzero_fast(it->__off,
		   sizeof(*it) - offsetof(TfwHPack, __off));
	TFW_STR_INIT(it->hdr);
}

static int
tfw_hpack_hdr_process(TfwHttpReq *req)
{
	int r = T_OK;
	TfwMsgParseIter *it = &req->pit;
	const TfwStr *chunk, *end, *hdr = it->hdr;

	BUG_ON(TFW_STR_DUP(hdr));
	if (TFW_STR_PLAIN(hdr)) {
		chunk = hdr;
		end = hdr + 1;
		WARN_ON_ONCE(chunk != it->next);
	} else {
		chunk = it->next;
		end = hdr->chunks + hdr->nchunks;
		WARN_ON_ONCE(hdr == it->next);
	}

	while (chunk < end) {
		r = tfw_h2_parse_hdr(chunk->data, chunk->len, req);
		if (unlikely(r < T_POSTPONE))
			return r;
		++chunk;
	}

	return T_OK;
}

/*
 * HPACK decoder FSM for HTTP/2 message processing.
 */
int
tfw_hpack_decode(TfwHPack *__restrict hp, const unsigned char *src,
		 unsigned long n, TfwHttpReq *__restrict req,
		 unsigned int *__restrict parsed)
{
	int r = T_POSTPONE;
	unsigned int state = hp->state;
	TfwMsgParseIter *it = &req->pit;
	const unsigned char *last = src + n;

	BUILD_BUG_ON(HPACK_STATE_MASK < _HPACK_STATE_NUM - 1);
	BUG_ON(!it->hdr);
	WARN_ON_ONCE(!n);
	*parsed = n;
	do {
		T_DBG3("%s: header processing, n=%lu, to_parse=%lu, state=%d\n",
		       __func__, n, last - src, state);
		switch (state & HPACK_STATE_MASK) {
		case HPACK_STATE_READY:
		{
			unsigned char c = *src++;

			if (c & 0x80) {
				T_DBG3("%s: reference by index...\n", __func__);

				state |= HPACK_FLAGS_NO_VALUE;
				hp->index = c & 0x7F;
				if (hp->index == 0x7F) {
					GET_FLEXIBLE(hp->index,
						     HPACK_STATE_INDEX);
				}
				else if (unlikely(hp->index == 0)) {
					r = T_DROP;
					goto out;
				}

				T_DBG3("%s: decoded index: %lu\n", __func__,
				       hp->index);

				NEXT_STATE(HPACK_STATE_ALL_INDEXED);

				goto get_all_indexed;

			} else if (c & 0x40) {
				T_DBG3("%s: reference with addition...\n",
				       __func__);
				state |= HPACK_FLAGS_ADD;
				hp->index = c & 0x3F;
				if (hp->index == 0x3F) {
index:
					GET_FLEXIBLE(hp->index, HPACK_STATE_INDEX);
					T_DBG3("%s: decoded index: %lu\n",
					       __func__, hp->index);
					NEXT_STATE(HPACK_STATE_INDEXED_NAME_TEXT);
					goto get_indexed_name;
				}

			} else if (c & 0x20) {
				T_DBG3("%s: new window size...\n", __func__);

				hp->index = c & 0x1F;
				if (hp->index == 0x1F)
					GET_FLEXIBLE(hp->index,
						     HPACK_STATE_WINDOW);

				T_DBG3("%s: decoded window: %lu\n", __func__,
				       hp->index);

				NEXT_STATE(HPACK_STATE_WINDOW);

				goto set_window;

			} else {
				T_DBG3("%s: reference with value...\n",
				       __func__);

				if (c & 0xE0) {
					T_DBG3("%s: the code of the header's"
					       " binary representation is not"
					       " in prefix form\n", __func__);
					r = T_DROP;
					goto out;
				}

				if (c & 0x10) {
					T_DBG3("%s: transit header...\n",
					      __func__);
					state |= HPACK_FLAGS_TRANSIT;
				}

				hp->index = c & 0x0F;
				if (hp->index == 0x0F) {
					NEXT_STATE(HPACK_STATE_INDEX);
					goto index;
				}
			}

			NEXT_STATE(hp->index
				   ? HPACK_STATE_INDEXED_NAME_TEXT
				   : HPACK_STATE_NAME);

			if (src >= last)
				goto out;

			if (hp->index) {
				T_DBG3("%s: decoded index: %lu\n", __func__,
				       hp->index);
				goto get_indexed_name;
			}

			/* Fall through. */
		}
		case HPACK_STATE_NAME:
		{
			unsigned char c = *src++;

			T_DBG3("%s: decode header name length...\n", __func__);
			hp->length = c & 0x7F;
			if (c & 0x80) {
				T_DBG3("%s: Huffman encoding used for name...\n",
				       __func__);
				state |= HPACK_FLAGS_HUFFMAN_NAME;
			}
			if (unlikely(hp->length == 0x7F)) {
				GET_FLEXIBLE(hp->length, HPACK_STATE_NAME_LENGTH);
			}
			else if (unlikely(hp->length == 0)) {
				r = T_DROP;
				goto out;
			}

			T_DBG3("%s: name length: %lu\n", __func__, hp->length);

			NEXT_STATE(HPACK_STATE_NAME_TEXT);

			BUFFER_NAME_OPEN(hp->length);

			if (unlikely(src >= last))
				goto out;

			/* Fall through. */
		}
		case HPACK_STATE_NAME_TEXT:
		{
			unsigned long m_len;
get_name_text:
			T_DBG3("%s: decode header name...\n", __func__);
			m_len = min((unsigned long)(last - src), hp->length);
			if (state & HPACK_FLAGS_HUFFMAN_NAME)
				HPACK_DECODE_STRING(m_len);
			else
				HPACK_COPY_STRING(m_len);

			if (tfw_hpack_hdr_process(req)) {
				r = T_DROP;
				goto out;
			}

			BUFFER_WRITE_COLON();

			NEXT_STATE(HPACK_STATE_VALUE);

			if (unlikely(src >= last))
				goto out;

			goto get_value;
		}
		case HPACK_STATE_INDEXED_NAME_TEXT:
		{
get_indexed_name:
			T_DBG3("%s: decode indexed (%lu) header name...\n",
			       __func__, hp->index);
			WARN_ON_ONCE(!hp->index);
			hp->entry = tfw_hpack_find_index(&hp->dec_tbl,
							 hp->index);
			if (!hp->entry) {
				r = T_DROP;
				goto out;
			}

			BUFFER_NAME_OPEN(hp->entry->name->len);
			BUFFER_WRITE(hp->entry->name->ptr,
				     hp->entry->name->len, it);

			if (!STATIC_INDEXED(hp->entry)) {
				if (tfw_hpack_hdr_process(req)) {
					r = T_DROP;
					goto out;
				}
			}
			else {
				it->hdr_tag = hp->entry->tag;
			}

			BUFFER_WRITE_COLON();

			NEXT_STATE(HPACK_STATE_VALUE);

			/* Fall through. */
		}
		case HPACK_STATE_VALUE:
		{
			unsigned char c;
get_value:
			T_DBG3("%s: decode header value length...\n", __func__);
			c = *src++;
			hp->length = c & 0x7F;
			if (c & 0x80) {
				T_DBG3("%s: Huffman encoding used for value\n",
				       __func__);
				state |= HPACK_FLAGS_HUFFMAN_VALUE;
			}
			if (unlikely(hp->length == 0x7F))
				GET_FLEXIBLE(hp->length,
					     HPACK_STATE_VALUE_LENGTH);

			T_DBG3("%s: value length: %lu\n", __func__, hp->length);

			NEXT_STATE(HPACK_STATE_VALUE_TEXT);

			BUFFER_VAL_OPEN(hp->length);

			if (unlikely(src >= last))
				goto out;

			/* Fall through. */
		}
		case HPACK_STATE_VALUE_TEXT:
		{
			unsigned long m_len;
get_value_text:
			WARN_ON_ONCE(state & HPACK_FLAGS_NO_VALUE);
			if (!hp->length) {
				T_DBG3("%s: zero-length value\n", __func__);
				r = T_DROP;
				goto out;
			}

			T_DBG3("%s: decode header value...\n", __func__);
			m_len = min((unsigned long)(last - src), hp->length);
			if (state & HPACK_FLAGS_HUFFMAN_VALUE)
				HPACK_DECODE_STRING(m_len);
			else
				HPACK_COPY_STRING(m_len);

			BUFFER_WRITE_CRLF();

			if (tfw_hpack_hdr_process(req)) {
				r = T_DROP;
				goto out;
			}

			tfw_str_set_eolen(it->hdr, 2);

			if (state & HPACK_FLAGS_ADD
			    && tfw_hpack_add_index(&hp->dec_tbl, hp->entry, it))
			{
				r = T_DROP;
				goto out;
			}

			break;
		}
		case HPACK_STATE_ALL_INDEXED:
		{
			const TfwHPackEntry *entry;
get_all_indexed:
			T_DBG3("%s: get entire header by index: %lu\n", __func__,
			       hp->index);
			WARN_ON_ONCE(!(state & HPACK_FLAGS_NO_VALUE));
			WARN_ON_ONCE(!hp->index);

			entry = tfw_hpack_find_index(&hp->dec_tbl, hp->index);
			if (!entry) {
				r = T_DROP;
				goto out;
			}

			BUFFER_NAME_OPEN(entry->name->len);
			BUFFER_WRITE(entry->name->ptr, entry->name->len, it);

			if (!STATIC_INDEXED(entry)) {
				if (tfw_hpack_hdr_process(req)) {
					r = T_DROP;
					goto out;
				}
			}
			else {
				it->hdr_tag = entry->tag;
			}

			BUFFER_WRITE_COLON();

			BUFFER_VAL_OPEN(entry->value->len);
			BUFFER_WRITE(entry->value->ptr, entry->value->len, it);
			BUFFER_WRITE_CRLF();

			tfw_str_set_eolen(it->hdr, 2);
			tfw_http_msg_hdr_close((TfwHttpMsg *)req, it->hdr_tag);

			break;
		}
		case HPACK_STATE_INDEX:
			GET_CONTINUE(hp->index);
			T_DBG3("%s: index finally decoded: %lu\n", __func__,
			       hp->index);
			if (state & HPACK_FLAGS_NO_VALUE) {
				NEXT_STATE(HPACK_STATE_ALL_INDEXED);
				goto get_all_indexed;
			}

			NEXT_STATE(HPACK_STATE_INDEXED_NAME_TEXT);

			if (unlikely(src >= last))
				goto out;

			goto get_indexed_name;

		case HPACK_STATE_WINDOW:
			GET_CONTINUE(hp->index);
			T_DBG3("%s: new window size finally decoded: %lu\n",
			       __func__, hp->index);
set_window:
			if (tfw_hpack_set_length(hp, hp->index)) {
				r = T_DROP;
				goto out;
			}
			T_DBG3("%s: window size has been changed\n", __func__);
			break;

		case HPACK_STATE_NAME_LENGTH:
			GET_CONTINUE(hp->length);
			T_DBG3("%s: name length finally decoded: %lu\n",
			       __func__, hp->length);

			NEXT_STATE(HPACK_STATE_NAME_TEXT);

			BUFFER_NAME_OPEN(hp->length);

			if (unlikely(src >= last))
				goto out;

			goto get_name_text;

		case HPACK_STATE_VALUE_LENGTH:
			GET_CONTINUE(hp->length);
			T_DBG3("%s: value length finally decoded: %lu\n",
			       __func__, hp->length);

			NEXT_STATE(HPACK_STATE_VALUE_TEXT);

			BUFFER_VAL_OPEN(hp->length);

			if (unlikely(src >= last))
				goto out;

			goto get_value_text;

		default:
			WARN_ON_ONCE(1);
			r = T_DROP;
			goto out;
		}

		T_DBG3("%s: new header added\n", __func__);

		tfw_hpack_reinit(hp, it);

	} while (src < last);

	return T_OK;
out:
	WARN_ON_ONCE(src > last);
	*parsed -= last - src;
	hp->state = state;
	return r;
}

/*
 * ------------------------------------------------------------------------
 *	HPACK Encoder functionality
 * ------------------------------------------------------------------------
 */

typedef struct {
	TfwHPackNode *parent;
	short *poff;
} TfwHPackNodeIter;

typedef enum {
	HPACK_IDX_ST_FOUND		= 0,
	HPACK_IDX_ST_NM_FOUND,
	HPACK_IDX_ST_NOT_FOUND,
	_HPACK_IDX_ST_NUM
} TfwHPackETblRes;

#define HPACK_IDX_ST_MASK		0x0F
#define HPACK_IDX_FLAG_ADD		0x010

#define HPACK_MAX_ENC_EVICTION		5

#define HPACK_RB_IS_BLACK(node)		((int)(node)->color)
#define HPACK_RB_IS_RED(node)		(!HPACK_RB_IS_BLACK(node))

#define HPACK_RB_SET_BLACK(node)					\
do {									\
	(node)->color = 1;						\
} while (0)

#define HPACK_RB_SET_RED(node)						\
do {									\
	(node)->color = 0;						\
} while (0)

#define HPACK_RB_COPY_COLOR(d_node, s_node)				\
do {									\
	(d_node)->color = (s_node)->color;				\
} while (0)

#define HPACK_NODE_EMPTY(off)		((off) < 0)

#define HPACK_NODE(tbl, off)						\
	((TfwHPackNode *)((tbl)->rbuf + (off)))

#define HPACK_NODE_COND(tbl, off)					\
	(!HPACK_NODE_EMPTY(off) ? HPACK_NODE(tbl, off) : NULL)

#define HPACK_NODE_OFF(tbl, node)					\
	((char *)(node) - (tbl)->rbuf)

#define HPACK_NODE_COND_OFF(tbl, node)					\
	((node) ? HPACK_NODE_OFF(tbl, node) : -1)

#define HPACK_NODE_ALIGN(sz)	(((sz) + 7) & ~7UL)

#define HPACK_NODE_SIZE(node)						\
	HPACK_NODE_ALIGN(sizeof(TfwHPackNode) + ((TfwHPackNode *)node)->hdr_len)

#define HPACK_NODE_NEXT(node)						\
	((TfwHPackNode *)((char *)(node) + HPACK_NODE_SIZE(node)))

typedef enum {
	HPACK_HDR_NAME_SEARCH		= 0,
	HPACK_HDR_NAME_FOUND,
	HPACK_HDR_VALUE_FOUND
} TfwHPackCmpStates;

#define HP_SH(p)			(*(unsigned short *)(p))
#define HP_CHAR(p)			(*(unsigned char *)(p))

#define SH_LC(p)			(HP_SH(p) | 0x2020)
#define CHAR_LC(p)			(HP_CHAR(p) | 0x20)

#define INT_LE(p)							\
	((p)[0] << 24 | (p)[1] << 16 | (p)[2] << 8 | (p)[3])
#define SH_LE(p)							\
	((p)[0] << 8 | (p)[1])

#define INT_LE_LC(p)			(INT_LE(p) | 0x20202020)
#define SH_LE_LC(p)			(SH_LE(p) | 0x2020)

/*
 * Processing header's OWS during comparison with values stored in encoder
 * dynamic index. Note that in switch '-1' branch for @idx - all characters
 * in processed part of @data are the OWS (or ':' in case of header's name
 * processing), thus mismatching is dummy and we can continue the comparison
 * procedure.
 */
#define HPACK_HDR_OWS_PROCESS(part_len, ret)				\
({									\
	bool found = false;						\
	short idx = (part_len) - 1;					\
									\
	BUG_ON(len < (part_len));					\
	if (state != HPACK_HDR_NAME_SEARCH				\
	    && (state != HPACK_HDR_VALUE_FOUND				\
		|| chunk != TFW_STR_LAST(hdr)				\
		|| len != (part_len)))					\
		return ret;						\
									\
	for (; (data[idx] == ' ' || data[idx] == '\t') && idx >= 0;	\
	     --idx);							\
	if (state == HPACK_HDR_NAME_SEARCH				\
	    && idx >= 0							\
	    && data[idx] == ':')					\
	{								\
		found = true;						\
		--idx;							\
	}								\
	if (idx == (part_len) - 1)					\
		return ret;						\
	T_DBG3("%s: ows, state=%d, part_len=%d, ret=%d, idx=%u,"	\
	       " pos='%.*s', data='%.*s'\n", __func__, state, part_len,	\
	       ret, idx, idx + 1, pos, idx + 1, data);			\
	switch (idx) {							\
	case 1:								\
		/* Fall through. */					\
	case 2:								\
		if (state == HPACK_HDR_NAME_SEARCH) {			\
			if (SH_LC(pos) != SH_LC(data))			\
				return ret;				\
		} else if (HP_SH(pos) != HP_SH(data)) {			\
			return ret;					\
		}							\
		if (idx == 1)						\
			break;						\
		/* Fall through. */					\
	case 0:								\
		if (state == HPACK_HDR_NAME_SEARCH) {			\
			if (CHAR_LC(pos + idx) == CHAR_LC(data + idx))	\
				break;					\
		}							\
		else if (HP_CHAR(pos + idx) == HP_CHAR(data + idx)) {	\
			break;						\
		}							\
		return ret;						\
	case -1:							\
		break;							\
	default:							\
		BUG();							\
	}								\
	if (found)							\
		state = HPACK_HDR_NAME_FOUND;				\
	idx;								\
})

#define HPACK_NODE_GET_INDEX(tbl, node)					\
({									\
	unsigned long idx = 0;						\
	if (node) {							\
		idx = ~((node)->rindex - (tbl)->idx_acc) + 1;		\
		WARN_ON_ONCE(idx >= HPACK_ENC_TABLE_MAX_SIZE);		\
		idx += HPACK_STATIC_ENTRIES + 1;			\
	}								\
	idx;								\
})

static int
tfw_hpack_node_compare(const TfwStr *__restrict hdr,
		       const TfwHPackNode *__restrict node,
		       const TfwHPackNode **__restrict nm_node)
{
	short i;
	const TfwStr *chunk, *end;
	unsigned long hlen = hdr->len;
	unsigned short node_hlen = node->hdr_len;
	const char *pos = node->hdr;
	TfwHPackCmpStates state = HPACK_HDR_NAME_SEARCH;

#define HDR_PART_SHIFT(t_part, s_part)					\
do {									\
	pos += t_part;							\
	node_hlen -= t_part;						\
	data += s_part;							\
	len -= s_part;							\
} while (0)

#define HDR_PART_COMPARE(part_len, ret)					\
do {									\
	i = HPACK_HDR_OWS_PROCESS(part_len, ret);			\
	T_DBG3("%s: ows processing, part_len=%u, state=%d, *nm_node=[%p]," \
	       " node->hdr_len=%hu, node_hlen=%hu, pos='%.*s', len=%hu," \
	       " data='%.*s'\n", __func__, part_len, state, *nm_node,	\
	       node->hdr_len, node_hlen, node_hlen, pos, len,		\
	       len, data);						\
	HDR_PART_SHIFT(i + 1, part_len);				\
	if (state == HPACK_HDR_NAME_FOUND) {				\
		if (!*nm_node)						\
			*nm_node = node;				\
		hlen -=	chunk->len - min_len;				\
		goto chunk_end;						\
	}								\
} while (0)

#define SHIFT(n)							\
	HDR_PART_SHIFT(n, n)

	TFW_STR_FOR_EACH_CHUNK(chunk, hdr, end) {
		unsigned short min_len, len;
		const char *data = chunk->data;

		if (!chunk->len)
			continue;

		T_DBG3("%s: state=%d, hlen=%lu, node_hlen=%hu, pos='%.*s',"
		       " chunk->len=%lu, chunk->data='%.*s'\n", __func__, state,
		       hlen, node_hlen, node_hlen, pos, chunk->len,
		       (int)chunk->len, data);

		if (state == HPACK_HDR_NAME_FOUND) {
			if (unlikely(data[0] == ' ' || data[0] == '\t')) {
				hlen -= chunk->len;
				continue;
			}
			state = HPACK_HDR_VALUE_FOUND;
		}

		len = min_len = min((unsigned long)node_hlen, chunk->len);
		hlen -= min_len;
		while (len >= 4) {
			if (state == HPACK_HDR_NAME_SEARCH) {
				if (INT_LE_LC(pos) > INT_LE_LC(data))
					HDR_PART_COMPARE(4, -1);
				else if (INT_LE_LC(pos) < INT_LE_LC(data))
					HDR_PART_COMPARE(4, 1);
				else
					SHIFT(4);
			}
			else {
				if (INT_LE(pos) > INT_LE(data))
					HDR_PART_COMPARE(4, -1);
				else if (INT_LE(pos) < INT_LE(data))
					HDR_PART_COMPARE(4, 1);
				else
					SHIFT(4);
			}
		}
		while (len >= 2) {
			if (state == HPACK_HDR_NAME_SEARCH) {
				if (SH_LE_LC(pos) > SH_LE_LC(data))
					HDR_PART_COMPARE(2, -1);
				else if (SH_LE_LC(pos) < SH_LE_LC(data))
					HDR_PART_COMPARE(2, 1);
				else
					SHIFT(2);
			}
			else {
				if (SH_LE(pos) > SH_LE(data))
					HDR_PART_COMPARE(2, -1);
				else if (SH_LE(pos) < SH_LE(data))
					HDR_PART_COMPARE(2, 1);
				else
					SHIFT(2);
			}
		}
		if (len) {
			if (state == HPACK_HDR_NAME_SEARCH) {
				if (CHAR_LC(pos) > CHAR_LC(data))
					HDR_PART_COMPARE(1, -1);
				else if (CHAR_LC(pos) < CHAR_LC(data))
					HDR_PART_COMPARE(1, 1);
				else
					SHIFT(1);
			}
			else {
				if (HP_CHAR(pos) > HP_CHAR(data))
					HDR_PART_COMPARE(1, -1);
				else if (HP_CHAR(pos) < HP_CHAR(data))
					HDR_PART_COMPARE(1, 1);
				else
					SHIFT(1);
			}
		}
chunk_end:
		if (!node_hlen) {
			unsigned long k = min_len;
			/*
			 * If we have matched @node_hlen characters of header,
			 * and the remained characters are OWS, then the entire
			 * header should be considered matched.
			 */
			WARN_ON_ONCE(state != HPACK_HDR_VALUE_FOUND);
			for (;;) {
				for (; k < chunk->len; ++k) {
					if (data[k] != ' ' && data[k] != '\t')
						return 1;
				}

				if (++chunk >= end)
					return 0;

				data = chunk->data;
				k = 0;
			}
		}
	}
	WARN_ON_ONCE(hlen);

	return node_hlen ? -1 : 0;

#undef HDR_PART_SHIFT
#undef HDR_PART_COMPARE
#undef SHIFT
}

/*
 * Left rotation of red-black tree.
 */
static void
tfw_hpack_rbtree_left_rt(TfwHPackETbl *__restrict tbl,
			 TfwHPackNode *__restrict old_apex)
{
	TfwHPackNode *child, *parent;
	TfwHPackNode *new_apex = HPACK_NODE_COND(tbl, old_apex->right);

	BUG_ON(!new_apex);
	old_apex->right = new_apex->left;

	child = HPACK_NODE_COND(tbl, new_apex->left);
	if (child)
		child->parent = HPACK_NODE_OFF(tbl, old_apex);

	new_apex->parent = old_apex->parent;
	parent = HPACK_NODE_COND(tbl, old_apex->parent);
	if (!parent)
	{
		tbl->root = new_apex;
	}
	else if (!HPACK_NODE_EMPTY(parent->left)
		 && old_apex == HPACK_NODE(tbl, parent->left))
	{
		parent->left = HPACK_NODE_OFF(tbl, new_apex);
	}
	else
	{
		parent->right = HPACK_NODE_OFF(tbl, new_apex);
	}

	new_apex->left = HPACK_NODE_OFF(tbl, old_apex);
	old_apex->parent = HPACK_NODE_OFF(tbl, new_apex);
}

/*
 * Right rotation of red-black tree.
 */
static void
tfw_hpack_rbtree_right_rt(TfwHPackETbl *__restrict tbl,
			  TfwHPackNode *__restrict old_apex)
{
	TfwHPackNode *child, *parent;
	TfwHPackNode *new_apex = HPACK_NODE_COND(tbl, old_apex->left);

	BUG_ON(!new_apex);
	old_apex->left = new_apex->right;

	child = HPACK_NODE_COND(tbl, new_apex->right);
	if (child)
		child->parent = HPACK_NODE_OFF(tbl, old_apex);

	new_apex->parent = old_apex->parent;
	parent = HPACK_NODE_COND(tbl, old_apex->parent);
	if (!parent)
	{
		tbl->root = new_apex;
	}
	else if (!HPACK_NODE_EMPTY(parent->left)
		 && old_apex == HPACK_NODE(tbl, parent->left))
	{
		parent->left = HPACK_NODE_OFF(tbl, new_apex);
	}
	else
	{
		parent->right = HPACK_NODE_OFF(tbl, new_apex);
	}

	new_apex->right = HPACK_NODE_OFF(tbl, old_apex);
	old_apex->parent = HPACK_NODE_OFF(tbl, new_apex);
}

/*
 * Procedure for red-black tree rebalancing after the new node insertion.
 */
static void
tfw_hpack_rbtree_ins_rebalance(TfwHPackETbl *__restrict tbl,
			       TfwHPackNode *__restrict new)
{
	TfwHPackNode *parent = HPACK_NODE_COND(tbl, new->parent);

	while (parent && HPACK_RB_IS_RED(parent)) {
		TfwHPackNode *gparent = HPACK_NODE_COND(tbl, parent->parent);
		TfwHPackNode *gp_left_child, *uncle;

		BUG_ON(!gparent);
		gp_left_child = HPACK_NODE_COND(tbl, gparent->left);
		if (parent == gp_left_child) {
			uncle = HPACK_NODE_COND(tbl, gparent->right);
			if (uncle && HPACK_RB_IS_RED(uncle)) {
				HPACK_RB_SET_BLACK(parent);
				HPACK_RB_SET_BLACK(uncle);
				HPACK_RB_SET_RED(gparent);
				parent = HPACK_NODE_COND(tbl, gparent->parent);
			}
			else {
				if (!HPACK_NODE_EMPTY(parent->right)
				    && new == HPACK_NODE(tbl, parent->right))
				{
					tfw_hpack_rbtree_left_rt(tbl, parent);
					parent = new;
				}
				HPACK_RB_SET_BLACK(parent);
				HPACK_RB_SET_RED(gparent);
				tfw_hpack_rbtree_right_rt(tbl, gparent);
			}
		}
		else {
			uncle = gp_left_child;
			if (uncle && HPACK_RB_IS_RED(uncle)) {
				HPACK_RB_SET_BLACK(parent);
				HPACK_RB_SET_BLACK(uncle);
				HPACK_RB_SET_RED(gparent);
				parent = HPACK_NODE_COND(tbl, gparent->parent);
			}
			else {
				if (!HPACK_NODE_EMPTY(parent->left)
				    && new == HPACK_NODE(tbl, parent->left))
				{
					tfw_hpack_rbtree_right_rt(tbl, parent);
					parent = new;
				}
				HPACK_RB_SET_BLACK(parent);
				HPACK_RB_SET_RED(gparent);
				tfw_hpack_rbtree_left_rt(tbl, gparent);
			}
		}
	}

	HPACK_RB_SET_BLACK(tbl->root);
}

/*
 * Procedure for red-black tree rebalancing after the node deletion.
 */
static void
tfw_hpack_rbtree_del_rebalance(TfwHPackETbl *__restrict tbl,
			       TfwHPackNode *__restrict nchild,
			       TfwHPackNode *__restrict parent,
			       bool left)
{
	BUG_ON(!tbl->root);

	while (!nchild || (nchild != tbl->root && HPACK_RB_IS_BLACK(nchild))) {
		TfwHPackNode *brother, *l_neph, *r_neph;

		if (left) {
			BUG_ON(HPACK_NODE_EMPTY(parent->right));
			brother = HPACK_NODE(tbl, parent->right);
			if (HPACK_RB_IS_RED(brother)) {
				HPACK_RB_SET_BLACK(brother);
				HPACK_RB_SET_RED(parent);
				tfw_hpack_rbtree_left_rt(tbl, parent);
				/*
				 * In case 1 @brother->left and @brother->right
				 * also cannot be empty leafs (otherwise the 5th
				 * property of red-black tree will be broken,
				 * since the @brother itself is red in case 1),
				 * so after left rotation we can use new @brother
				 * as non-empty node.
				 */
				brother = HPACK_NODE_COND(tbl, parent->right);
				BUG_ON(!brother);
			}

			l_neph = HPACK_NODE_COND(tbl, brother->left);
			r_neph = HPACK_NODE_COND(tbl, brother->right);
			if ((!l_neph || HPACK_RB_IS_BLACK(l_neph))
			    && (!r_neph || HPACK_RB_IS_BLACK(r_neph)))
			{
				HPACK_RB_SET_RED(brother);
				nchild = parent;
			}
			else
			{
				if  (!r_neph || HPACK_RB_IS_BLACK(r_neph)) {
					HPACK_RB_SET_BLACK(l_neph);
					HPACK_RB_SET_RED(brother);
					tfw_hpack_rbtree_right_rt(tbl, brother);
					r_neph = brother;
					brother = HPACK_NODE_COND(tbl,
								  parent->right);
				}
				HPACK_RB_COPY_COLOR(brother, parent);
				HPACK_RB_SET_BLACK(parent);
				HPACK_RB_SET_BLACK(r_neph);
				tfw_hpack_rbtree_left_rt(tbl, parent);
				nchild = tbl->root;
			}
		}
		else {
			BUG_ON(HPACK_NODE_EMPTY(parent->left));
			brother = HPACK_NODE(tbl, parent->left);

			if (HPACK_RB_IS_RED(brother)) {
				HPACK_RB_SET_BLACK(brother);
				HPACK_RB_SET_RED(parent);
				tfw_hpack_rbtree_right_rt(tbl, parent);
				brother = HPACK_NODE_COND(tbl, parent->left);
				BUG_ON(!brother);
			}

			l_neph = HPACK_NODE_COND(tbl, brother->left);
			r_neph = HPACK_NODE_COND(tbl, brother->right);
			if ((!l_neph || HPACK_RB_IS_BLACK(l_neph))
			    && (!r_neph || HPACK_RB_IS_BLACK(r_neph)))
			{
				HPACK_RB_SET_RED(brother);
				nchild = parent;
			}
			else
			{
				if  (!l_neph || HPACK_RB_IS_BLACK(l_neph)) {
					HPACK_RB_SET_BLACK(r_neph);
					HPACK_RB_SET_RED(brother);
					tfw_hpack_rbtree_left_rt(tbl, brother);
					l_neph = brother;
					brother = HPACK_NODE_COND(tbl,
								  parent->left);
				}
				HPACK_RB_COPY_COLOR(brother, parent);
				HPACK_RB_SET_BLACK(parent);
				HPACK_RB_SET_BLACK(l_neph);
				tfw_hpack_rbtree_right_rt(tbl, parent);
				nchild = tbl->root;
			}
		}
	}

	HPACK_RB_SET_BLACK(nchild);
}

static inline TfwHPackNode *
tfw_hpack_rbtree_min(TfwHPackETbl *__restrict tbl,
		     TfwHPackNode *__restrict node)
{
	BUG_ON(!node);

	while (!HPACK_NODE_EMPTY(node->left)) {
		node = HPACK_NODE(tbl, node->left);
	}

	return node;
}

/*
 * Procedure for branches replacement in red-black tree.
 */
static inline bool
tfw_hpack_rbtree_replace(TfwHPackETbl *__restrict tbl,
			 TfwHPackNode *__restrict old,
			 TfwHPackNode *__restrict new)
{
	bool left = true;
	TfwHPackNode *parent = HPACK_NODE_COND(tbl, old->parent);

	BUG_ON(!old);
	if (!parent)
	{
		WARN_ON_ONCE(tbl->root != old);
		tbl->root = new;
	}
	else if (!HPACK_NODE_EMPTY(parent->left)
		 && old == HPACK_NODE(tbl, parent->left))
	{
		parent->left = HPACK_NODE_COND_OFF(tbl, new);
	}
	else
	{
		WARN_ON_ONCE(HPACK_NODE_EMPTY(parent->right)
			     || old != HPACK_NODE(tbl, parent->right));
		parent->right = HPACK_NODE_COND_OFF(tbl, new);
		left = false;
	}

	if (new)
		new->parent = HPACK_NODE_COND_OFF(tbl, parent);

	return left;
}

/*
 * Add @new node into the red-black tree in appropriate place passed from the caller
 * (and ultimately - from the @tfw_hpack_rbtree_find() unsuccessful call) in @it
 * argument.
 */
static void
tfw_hpack_rbtree_add(TfwHPackETbl *__restrict tbl, TfwHPackNode *__restrict new,
		     TfwHPackNodeIter *__restrict it)
{
	TfwHPackNode *parent = it->parent;
	short *poff = it->poff;

	new->parent = HPACK_NODE_COND_OFF(tbl, parent);
	if (!parent) {
		BUG_ON(tbl->root);
		tbl->root = new;
	}
	else {
		*poff = HPACK_NODE_OFF(tbl, new);
	}

	new->right = new->left = -1;
	HPACK_RB_SET_RED(new);

	tfw_hpack_rbtree_ins_rebalance(tbl, new);
}

/*
 * Find node which matches the required header @hdr in the red-black tree and
 * pass it to the caller in @out_node variable. If only header name is found,
 * the corresponding node is also passed upstairs, and appropriate  value is
 * returned to the caller. Note, that in case of unsuccessful search, the last
 * processed node with appropriate leaf is passed to caller in @out_place
 * variable and can be used for adding new node in correct place without
 * additional tree search (see comment for @tfw_hpack_rbtree_add() above).
 */
static TfwHPackETblRes
tfw_hpack_rbtree_find(TfwHPackETbl *__restrict tbl,
		      const TfwStr *__restrict hdr,
		      const TfwHPackNode **__restrict out_node,
		      TfwHPackNodeIter *__restrict out_place)
{
	int res;
	TfwHPackNode *parent = NULL;
	TfwHPackNode *node = tbl->root;
	const TfwHPackNode *nm_node = NULL;

	while (node) {
		parent = node;
		res = tfw_hpack_node_compare(hdr, node, &nm_node);

		if (res < 0)
			node = HPACK_NODE_COND(tbl, node->left);
		else if (res > 0)
			node = HPACK_NODE_COND(tbl, node->right);
		else {
			*out_node = node;
			return HPACK_IDX_ST_FOUND;
		}
	}

	out_place->parent = parent;

	if (!parent)
		out_place->poff = NULL;
	else if (res < 0)
		out_place->poff = &parent->left;
	else
		out_place->poff = &parent->right;

	/*
	 * If the node for the whole header @hdr is not found, but instead the
	 * node with header name is found, the pointer to that node must be
	 * assigned to the @nm_node. In this case the node with header name
	 * should be returned to the caller with special return value
	 * HPACK_IDX_ST_NM_FOUND indicating that only the name of header
	 * has been found, not the entire header.
	 */
	if (nm_node) {
		*out_node = nm_node;
		return HPACK_IDX_ST_NM_FOUND;
	}

	return HPACK_IDX_ST_NOT_FOUND;
}

/*
 * Remove specified node from the read-black tree.
 */
static void
tfw_hpack_rbtree_erase(TfwHPackETbl *__restrict tbl,
		       TfwHPackNode *__restrict node)
{
	TfwHPackNode *nchild, *sv = node;
	TfwHPackNode *parent = HPACK_NODE_COND(tbl, node->parent);
	bool left_child = false, sv_black = HPACK_RB_IS_BLACK(sv);

	if (HPACK_NODE_EMPTY(node->left)) {
		nchild = HPACK_NODE_COND(tbl, node->right);
		left_child = tfw_hpack_rbtree_replace(tbl, node, nchild);
	}
	else if (HPACK_NODE_EMPTY(node->right)) {
		nchild = HPACK_NODE_COND(tbl, node->left);
		left_child = tfw_hpack_rbtree_replace(tbl, node, nchild);
	}
	else {
		TfwHPackNode *n_left;

		sv = tfw_hpack_rbtree_min(tbl, HPACK_NODE(tbl, node->right));
		sv_black = HPACK_RB_IS_BLACK(sv);

		nchild = HPACK_NODE_COND(tbl, sv->right);

		if (node != HPACK_NODE(tbl, sv->parent)) {
			TfwHPackNode *n_right;

			parent = HPACK_NODE(tbl, sv->parent);
			left_child = tfw_hpack_rbtree_replace(tbl, sv, nchild);

			n_right = HPACK_NODE(tbl, node->right);
			n_right->parent = HPACK_NODE_OFF(tbl, sv);
			sv->right = node->right;
		}
		else {
			parent = sv;
		}

		tfw_hpack_rbtree_replace(tbl, node, sv);

		n_left = HPACK_NODE(tbl, node->left);
		n_left->parent = HPACK_NODE_OFF(tbl, sv);
		sv->left = node->left;

		HPACK_RB_COPY_COLOR(sv, node);
	}

	/*
	 * It makes sense to perform re-balancing only if the relocated/deleted
	 * node is BLACK and if tree is not empty (i.e. the deleted node is not
	 * the last).
	 */
	if (sv_black && tbl->root)
		tfw_hpack_rbtree_del_rebalance(tbl, nchild, parent, left_child);
}

static inline void
tfw_hpack_rbuf_iter(TfwHPackETbl *__restrict tbl,
		    TfwHPackETblIter *__restrict iter)
{
	iter->first = tbl->first;
	iter->last = tbl->last;
	iter->rb_len = tbl->rb_len;
	iter->rb_size = tbl->rb_size;
	iter->size = tbl->size;
}

static int
tfw_hpack_rbuf_calc(TfwHPackETbl *__restrict tbl, unsigned short new_size,
		    TfwHPackNode *__restrict del_list[],
		    TfwHPackETblIter *__restrict it)
{
	int i = 0;
	char *first = (char *)it->first;
	char *last = (char *)it->last;
	char *rbuf = tbl->rbuf;
	unsigned short size = it->size;
	unsigned short rb_len = it->rb_len;
	unsigned short last_len = HPACK_NODE_SIZE(last);

	WARN_ON_ONCE(!first || !last);
	do {
		unsigned short f_len, fhdr_len;

		if (i >= HPACK_MAX_ENC_EVICTION)
			return -E2BIG;

		if (last == first) {
			it->first = it->last = NULL;
			it->rb_len = it->size = 0;
			WARN_ON_ONCE(it->rb_size != HPACK_ENC_TABLE_MAX_SIZE);
			T_DBG3("%s: table is empty (rbuf=[%p])\n", __func__,
			       rbuf);
			return 0;
		}

		f_len = HPACK_NODE_SIZE(first);
		fhdr_len = ((TfwHPackNode *)first)->hdr_len;

		T_DBG3("%s: rb_len=%hu, size=%hu, new_size=%hu, rbuf=[%p],"
		       " first=[%p], last=[%p], f_len=%hu, fhdr_len=%hu,"
		       " last_len=%hu\n", __func__, rb_len, size, new_size,
		       rbuf, first, last, f_len, fhdr_len, last_len);

		if (del_list)
			del_list[i++] = (TfwHPackNode *)first;
		else
			tfw_hpack_rbtree_erase(tbl, (TfwHPackNode *)first);

		if (last < first && rb_len - f_len == last - rbuf + last_len) {
			it->rb_size = HPACK_ENC_TABLE_MAX_SIZE;
			first = rbuf;
		}
		else {
			first = (char *)HPACK_NODE_NEXT(first);
		}

		size -= HPACK_ENTRY_OVERHEAD + fhdr_len;
		rb_len -= f_len;

	} while (size > new_size);

	it->size = size;
	it->rb_len = rb_len;
	it->first = (TfwHPackNode *)first;

	return 0;
}

static inline void
tfw_hpack_rbuf_commit(TfwHPackETbl *__restrict tbl,
		      TfwHPackNode *__restrict del_list[],
		      TfwHPackNodeIter *__restrict place,
		      TfwHPackETblIter *__restrict iter)
{
	int i;

	for (i = 0; i < HPACK_MAX_ENC_EVICTION; ++i) {
		TfwHPackNode *del_node = del_list[i];

		if (!del_node)
			break;
		tfw_hpack_rbtree_erase(tbl, del_node);
	}

	tfw_hpack_rbtree_add(tbl, iter->last, place);

	tbl->first = iter->first;
	tbl->last = iter->last;
	tbl->rb_len = iter->rb_len;
	tbl->rb_size = iter->rb_size;
	tbl->size = iter->size;
}

/*
 * Add new header into the encoder dynamic index. If new size of index table
 * will be greater than current maximum allowed table size, the excess old
 * headers will be evicted from the index table.
 */
static int
tfw_hpack_add_node(TfwHPackETbl *__restrict tbl, const TfwStr *__restrict hdr,
		   TfwHPackNodeIter *__restrict place)
{
	unsigned long node_size, hdr_len;
	unsigned short new_size, node_len;
	unsigned short cur_size = tbl->size, window = tbl->window;
	unsigned long nm_len = 0, val_off = 0, val_len = 0;
	TfwHPackNode *del_list[HPACK_MAX_ENC_EVICTION] = {};
	TfwHPackETblIter it = {};

	hdr_len = tfw_http_msg_hdr_length(hdr, &nm_len, &val_off, &val_len);

	WARN_ON_ONCE(cur_size > window || window > HPACK_ENC_TABLE_MAX_SIZE);
	if ((node_size = hdr_len + HPACK_ENTRY_OVERHEAD) > window) {
		T_DBG3("%s: header is too big (node_size = %lu, window = %hu)"
		       " and cannot be added into index\n", __func__, node_size,
		       window);
		return -E2BIG;
	}

	/*
	 * Overflow cannot occur in @new_size, since it has unsigned short
	 * integer type, and @cur_size as well as @node_size must be not greater
	 * than SHRT_MAX.
	 */
	new_size = cur_size + node_size;
	WARN_ON_ONCE(new_size < node_size);
	T_DBG3("%s: window=%hu, size=%hu, new_size=%hu, node_size=%lu\n",
	       __func__, window, cur_size, new_size, node_size);

	/*
	 * Taking into account the ring buffer structure there may be cases when
	 * we will have enough space in @window pseudo-size for new entry, but
	 * not enough space in ring buffer itself. These situations can arise
	 * when the same entry should be placed in the end and in the beginning
	 * area of ring buffer (wrapped), but since the entry cannot be splitted,
	 * it will not fit neither at the end of buffer, nor at the start. Even
	 * if the entry fits at the beginning of the ring buffer, the size of
	 * the buffer will be reduced by the size of unused end space, and the
	 * situation with too large entry can arise in future (until the buffer
	 * will be wrapped and end space delta will be discarded). Thus, due to
	 * necessity of keeping the index tables on both sides of HTTP/2
	 * connection in synchronized state during adding new entry, we need at
	 * first calculate the changes for ring buffer in @it and then commit
	 * them; in this way, if new entry will not fit into the buffer, we can
	 * safely discard all changes keeping tables on server and client sides
	 * in consistent state.
	 */
	tfw_hpack_rbuf_iter(tbl, &it);

	if (new_size > window
	    && tfw_hpack_rbuf_calc(tbl, window - node_size, del_list, &it))
		return -E2BIG;

	node_len = HPACK_NODE_ALIGN(sizeof(TfwHPackNode) + hdr_len);

	if (it.rb_size < it.rb_len + node_len) {
		WARN_ON_ONCE(it.rb_size == HPACK_ENC_TABLE_MAX_SIZE);
		return -E2BIG;
	}
	else if (!it.first) {
		it.first = it.last = (TfwHPackNode *)tbl->rbuf;
		T_DBG3("%s: reset, rbuf=[%p] rb_len=%hu, rb_size=%hu, size=%hu,"
		       " node_len=%hu\n",  __func__, tbl->rbuf, it.rb_len,
		       it.rb_size, it.size, node_len);
		goto commit;
	}
	else if (it.first <= it.last) {
		unsigned short last_len = HPACK_NODE_SIZE(it.last);
		unsigned short end_space = HPACK_ENC_TABLE_MAX_SIZE;
		/*
		 * In this case @rb_size must always be reset before
		 * (in @tfw_hpack_rbuf_calc()).
		 */
		WARN_ON_ONCE(it.rb_size != HPACK_ENC_TABLE_MAX_SIZE);
		end_space -= ((char *)it.last - tbl->rbuf) + last_len;
		if (end_space < node_len) {
			T_DBG3("%s: wrap, rbuf=[%p], first=[%p], last=[%p],"
			       " rb_len=%hu, rb_size=%hu, size=%hu,"
			       " end_space=%hu, node_len=%hu\n", __func__,
			       tbl->rbuf, it.first, it.last, it.rb_len,
			       it.rb_size, it.size, end_space, node_len);

			if (it.rb_size - end_space < it.rb_len + node_len)
				return -E2BIG;

			it.rb_size -= end_space;
			it.last = (TfwHPackNode *)tbl->rbuf;

			goto commit;
		}
	}

	it.last = HPACK_NODE_NEXT(it.last);

	T_DBG3("%s: next node, rbuf=[%p], first=[%p], last=[%p], rb_len=%hu,"
	       " rb_size=%hu, size=%hu, node_len=%hu\n", __func__, tbl->rbuf,
	       it.first, it.last, it.rb_len, it.rb_size, it.size, node_len);

commit:
	it.size += node_size;
	it.rb_len += node_len;
	it.last->hdr_len = hdr_len;
	it.last->rindex = ++tbl->idx_acc;

	tfw_http_msg_hdr_write(hdr, nm_len, val_off, val_len, it.last->hdr);
	tfw_hpack_rbuf_commit(tbl, del_list, place, &it);

	WARN_ON_ONCE(tbl->rb_len > tbl->size);

	return 0;
}

/*
 * HPACK encoder index determination procedure. Operates with connection-wide
 * encoder dynamic table with potentially concurrent access from different
 * threads, so lock is used to protect the find/add/erase operations inside
 * this procedure.
 *
 * TODO #309: this function must be called from response sending procedures:
 * upstream response headers cycle, upstream response adjusting procedure,
 * internal response creation; in all these three cases the call to this
 * function must be combined with the sending of fully prepared response,
 * in which the @entered variable must be checked; callers of this procedure
 * must decide (taking into account information from static indexing: the
 * index itself and the special flag indicating whether the entire header
 * is indexed or only its name) - whether to call this function and which
 * index to send - static or dynamic; note, that dynamic index is returned
 * from this function with its own attributes to be taken into account: return
 * header/name values and special addition flag, signaling that the header
 * must be added into decoder index table on the client side; also note,
 * that if only header name has been found (in static or dynamic table), we
 * must save in dynamic table (under new index) the entire header nevertheless.
 */
static TfwHPackETblRes
tfw_hpack_encoder_index(TfwHPackETbl *__restrict tbl,
			const TfwStr *__restrict hdr,
			bool *entered, unsigned short *__restrict out_index)
{
	TfwHPackETblRes res;
	const TfwHPackNode *node = NULL;
	TfwHPackNodeIter place = {};

	BUILD_BUG_ON(HPACK_IDX_ST_MASK < _HPACK_IDX_ST_NUM - 1);

	spin_lock(&tbl->lock);

	if (!*entered && atomic64_read(&tbl->guard) < 0)
		goto out;

	res = tfw_hpack_rbtree_find(tbl, hdr, &node, &place);

	WARN_ON_ONCE(res != HPACK_IDX_ST_NOT_FOUND && !node);

	*out_index = HPACK_NODE_GET_INDEX(tbl, node);

	/*
	 * Encoder dynamic index can be in three states: initial state (@guard
	 * is zero), read state (@guard is 1 or greater), and write state
	 * (@guard is -1); in read state any thread can search in index, but
	 * nobody can add or evict entries in index; if index in write state
	 * only one thread (current writer) can add/evict entries in index and
	 * nobody can search in index; index can be switched to write state
	 * only from initial state (in general case) or from read state (if
	 * current reader is the sole read owner of the index).
	 */
	if (!*entered) {
		if(res != HPACK_IDX_ST_FOUND
		   && !atomic64_read(&tbl->guard)
		   && !tfw_hpack_add_node(tbl, hdr, &place))
		{
			res |= HPACK_IDX_FLAG_ADD;
			atomic64_set(&tbl->guard, -1);
			*entered = true;
		}
		else if (res != HPACK_IDX_ST_NOT_FOUND)
		{
			atomic64_inc(&tbl->guard);
			*entered = true;
		}
	}
	else {
		/*
		 * If value of guard is 1, we are the sole owner of the encoder
		 * dynamic index with read rights, thus we can write to it.
		 * Note, that @guard cannot be zero here, since we are already
		 * owning encoder index with read or write rights (the value of
		 * @entered is 'true'), thus we have already set the @guard
		 * equal to 1 (or greater) or to -1 before.
		 */
		WARN_ON_ONCE(!atomic64_read(&tbl->guard));
		if (res != HPACK_IDX_ST_FOUND
		    && atomic64_read(&tbl->guard) <= 1
		    && !tfw_hpack_add_node(tbl, hdr, &place))
		{
			res |= HPACK_IDX_FLAG_ADD;
			atomic64_set(&tbl->guard, -1);
		}
	}

out:
	spin_unlock(&tbl->lock);

	return res;
}

int
tfw_hpack_hdrs_transform(TfwHttpResp *__restrict resp, bool *entered)
{
	TfwHPackETblRes r;
	const TfwStr *field, *hdrs_end, *hdr, *dup_end;
	TfwH2Ctx *ctx = tfw_h2_context(resp->req->conn);
	unsigned short index = 0;

	FOR_EACH_HDR_FIELD(field, hdrs_end, resp) {
		TFW_STR_FOR_EACH_DUP(hdr, field, dup_end) {
			r = tfw_hpack_encoder_index(&ctx->hpack.enc_tbl, hdr,
						    entered, &index);
			/*
			 * TODO #309: replace response headers with HTTP/2
			 * indexes.
			 */
		}
	}

	return 0;
}

static inline void
tfw_hpack_set_rbuf_size(TfwHPackETbl *__restrict tbl, unsigned short new_size)
{
	WARN_ON_ONCE(new_size > HPACK_ENC_TABLE_MAX_SIZE);

	spin_lock(&tbl->lock);

	T_DBG3("%s: tbl->rb_len=%hu, tbl->size=%hu, new_size=%hu\n", __func__,
	       tbl->rb_len, tbl->size, new_size);

	if (tbl->size > new_size)
		tfw_hpack_rbuf_calc(tbl, new_size, NULL,
				    (TfwHPackETblIter *)tbl);
	WARN_ON_ONCE(tbl->rb_len > tbl->size);

	tbl->window = new_size;

	spin_unlock(&tbl->lock);
}
